
[TOC]
## 1.简述FTP工作流程

<center> 建立连接阶段 --> 身份认证阶段 --> 命令交互阶段 --> 断开连接阶段 </center>

1. FTP 客户端通过 TCP 三次握手与FTP服务器端进行建立连接，并向客户端发送身份认证请求。
2. 客户端要向FTP服务提供登录所需的用户名和密码，FTP应答后，进入FTP会话。
3. 用户执行FTP命令，服务器将命令的执行结果返回给客户端
4. 客户端向 FTP 服务器发送断开连接请求，服务器收到断开连接后给出相应的应答。
> http://c.biancheng.net/view/6479.html

---

## 2.同步I/O和异步I/O本质区别
同步：程序完全按照代码顺序执行
异步：程序的执行需要由**系统事件**来驱动，常见的系统事件包括中断、信号等
区别即是否等待I/O执行结果

---

## 3.TCP和UDP的区别及TCP怎么保证传输的可靠性

TCP和UDP的区别：
TCP是面向连接的、面向字节流、对系统的资源要求多、是可靠传输，UDP是面向无连接的、面向数据报、对系统的资源要求少、是不可靠传输。
对于TCP怎么保证传输的可靠性，刚开始我还以为要说三次握手啥的，没想到下来一看还不是。
* TCP协议保证数据传输可靠性的方式主要有：`校验和、序列号、确认应答、超时重传、连接管理（三次握手四次挥手）、流量控制、拥塞控制`。

---

## 4.短链接和长链接的区别
1. 短连接
   连接->传输数据->关闭连接
    比如HTTP是无状态的的短链接，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。因为连接后接收了数据就断开了，所以每次数据接受处理不会有联系。 这也是HTTP协议无状态的原因之一。

2. 长链接
    连接->传输数据->保持连接 -> 传输数据-> ...........->直到一方关闭连接，多是客户端关闭连接。长连接指建立SOCKET连接后不管是否使用都保持连接，但**安全性较差**。
3. 什么时候用长连接，短连接？
   长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费；而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。

---

## 5. Tcp
TCP 是一个面向连接的，安全的，流式传输协议，这个协议是一个传输层协议。

* `面向连接`：是一个双向连接，通过三次握手完成，断开连接需要通过四次挥手完成。
* `安全的`：tcp 通信过程中，会对发送的每一数据包都会进行校验，如果发现数据丢失，会自动重传.
* `流式传输`：发送端和接收端处理数据的速度，数据的量都可以不一致.
<center><img src="https://subingwen.cn/linux/socket/tcp.jpg"></img></center>

---

### 0、tcp 协议介绍

<center><img src="https://subingwen.cn/linux/three-four/tcp.png"></img></center>
<center>

<img src="https://img-blog.csdnimg.cn/b3d0e512edd548aa9eb3266eb337edad.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rlc3RpbnlfemM=,size_16,color_FFFFFF,t_70"></img>
</center>

* `源端口和目的端口`: 各占两个字节，分别写入源端口号和目的端口号。 
* `序号` ： 占4个字节；用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数
长度为 100 字节，那么下一个报文段的序号应为 401。 
* `确认号` ： 占4个字节；期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 
* `数据偏移` ： 占4位；指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。
* `确认 ACK` ： 当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 
* `同步 SYN` ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 
* `终止 FIN `： 用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 
* `窗口` ： 占2字节；窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 
* `检验和`： 占2个字节；检验和字段检验的范围包括首部和数据这两个部分。在计算检验和时，在TCP报文段的前面加上12字节的伪首部。
* `紧急指针字段`：占 16 位，指出在本报文段中紧急数据共有多少个字节(紧急数据放在本报文段数据的最前面)；
* `套接字`： TCP连接的端点叫做套接字或插口。端口号拼接到IP地址即构成了套接字。
* 
1. **序列号seq**
占4个字节，用来**标记数据段的顺序**，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生，给字节编上序号后，就给每一个报文段指派一个序号，序列号seq就是这个报文段中的第一个字节的数据编号。
2. **确认号ack**
占4个字节，期待收到对方下一个报文段的第一个数据字节的序号，序列号表示报文段携带数据的第一个字节的编号，而确认号指的是期望接受到下一个字节的编号，因此挡墙报文段最后一个字节的编号+1即是确认号。
3. **确认ACK**
占1个比特位，仅当ACK=1，确认号字段才有效。ACK=0，确认号无效。
4. **同步SYN**
连接建立时用于同步序号。当SYN=1，ACK=0表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使用SYN=1，ACK=1.因此，SYN=1表示这是一个连接请求，或连接接收报文，SYN这个标志位只有在TCP建立连接才会被置为1，握手完成后SYN标志位被置为0.
5. **终止FIN**

---

### 1、TCP三次握手

<center>
<img src="https://img-blog.csdnimg.cn/fe482ee55eb34f1a852a7c7d98f5d001.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rlc3RpbnlfemM=,size_16,color_FFFFFF,t_70" width="40%" height="40%"></img>
</center>



**第一次握手**：`Client`将SYN置1，随机产生一个初始序列号`seq`发送给`Server`，进入`SYN_SENT状`态；
**第二次握手**：`Server`收到Client的`SYN=1`之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个`acknowledge number=sequence number+1`，并随机产生一个自己的初始序列号，发送给客户端；进`入SYN_RCVD`状态；
**第三次握手**：客户端检查`acknowledge number`是否为序列号+1，`ACK`是否为1，检查正确之后将自己的`ACK`置为1，产生一个`acknowledge number=`服务器发的序列号+1，发送给服务器；进入`ESTABLISHED`状态；服务器检查ACK为1和`acknowledge number`为序列号+1之后，也进入`ESTABLISHED`状态；完成三次握手，连接建立。

---

### 2、TCP四次挥手

<center>
<img src="https://img-blog.csdnimg.cn/b95982295c704079848ad6c2f23ed20f.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rlc3RpbnlfemM=,size_16,color_FFFFFF,t_70" width="50%" height="50%"></img>
</center>

以客户端主动发起断开连接为例：
1. 第一次挥手：客户端发送 `FIN=1，seq=x(此处的x不是随机生成，而是最后一个要发送的数据的序列号)` 表示主动向服务器端断开连接，此时进入`FIN_WAIT_1`状态；
2. 第二次挥手：服务端收到消息，此时服务端可能还未接受完消息，所以向客户端回复`ACK=1,ack=x+1`,表示服务端收到断开请求，并且同意断开，但是还未完成数据接收。此时客户端进入`FIN_WAIT_2`状态；服务端进入`CLOSE_WAIT`状态。
3. 第三次挥手：服务端向客户端发送`FIN=1，seq=y(此处的y不是随机生成，而是服务端发送的数据的序列号)`，表示，数据已经接受完毕，可以断开连接；服务端进入`LAST_ACK`状态；
4. 第四次挥手：客户端收到服务端的断开请求，并发送`ACK=1,seq=y+1`，表示同意断开连接；此时服务端会直接进入`CLOSE`状态，而客户端需要进入`TIME_WAIT`状态，最后进入`CLOSE`状态；

---

### 3、流量控制

<center>
<img src="https://img-blog.csdnimg.cn/c1256a4f3c7847878f9a9bec18335bcf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rlc3RpbnlfemM=,size_16,color_FFFFFF,t_70"></img>
</center>

使用`滑动窗口协议`实现流量控制。**防止发送方发送速率太快，接收方缓存区不够导致溢出**。接收方会维护一个接收窗口 receiver window（窗口大小单位是字节），接受窗口的大小是根据自己的资源情况动态调整的，在返回ACK时将接受窗口大小放在TCP报文中的窗口字段告知发送方。发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口右移。

发送窗口的上限为接受窗口和拥塞窗口中的较小值。接受窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力。

流量控制可以让发送端根据接收端的实际接受能力控制发送的数据量。它的具体操作是，`接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不会超过该大小的数据，该限制大小即为窗口大小，即窗口大小由接收端主机决定。`

TCP 首部中，专门有一个字段来通知窗口大小，接收主机将自己可以接收的缓冲区大小放在该字段中通知发送端。当接收端的缓冲区面临数据溢出时，窗口大小的值也是随之改变，设置为一个更小的值通知发送端，从而控制数据的发送量，这样达到流量的控制。这个控制流程的窗口也可以称作滑动窗口。

这个图是一个单向的数据发送:
<center>
<img src="https://subingwen.cn/linux/three-four/sliding_window.png" ></img>
</center>
<center>
<img src="https://img-blog.csdnimg.cn/9b3b784aae074d01aa85bf33f9debd24.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rlc3RpbnlfemM=,size_16,color_FFFFFF,t_70"></img>
</center>

基于 TCP 通信的流程图，记录了从三次握手 -> 数据通信 -> 四次挥手是全过程：

<center>

<img src="https://img-blog.csdnimg.cn/451a4d76733e4c5094c140319e5f044a.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rlc3RpbnlfemM=,size_16,color_FFFFFF,t_70"></img>

</center>

![请添加图片描述](https://img-blog.csdnimg.cn/808ea993e72a469cbe976dc7df1a0cf0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rlc3RpbnlfemM=,size_16,color_FFFFFF,t_70)

![请添加图片描述](https://img-blog.csdnimg.cn/77efa911bced4a048fbc94e7fa44faaa.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rlc3RpbnlfemM=,size_16,color_FFFFFF,t_70)

![请添加图片描述](https://img-blog.csdnimg.cn/011a8461415d4d8aa826ffd1483c322b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rlc3RpbnlfemM=,size_16,color_FFFFFF,t_70)

链接: https://subingwen.cn/linux/three-four/#3-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6
来源: 爱编程的大丙
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

---

### 4、阻塞控制
[视频资料](https://www.bilibili.com/video/BV1c4411d7jb)
拥塞控制主要由四个算法组成：慢启动（Slow Start）、拥塞避免（Congestion voidance）、快重传 （Fast Retransmit）、快恢复（Fast Recovery）
慢启动：刚开始发送数据时，先把**拥塞窗口**（congestion window）设置为一个最大报文段MSS的数值，每收到一个新的确认报文之后，就把拥塞窗口加1个MSS。这样每经过一个传输轮次（或者说是每经过一个往返时间RTT），拥塞窗口的大小就会加倍;
拥塞避免：当拥塞窗口的大小达到**慢开始门限**(slow start threshold)时，开始执行拥塞避免算法，拥塞窗口大小不再指数增加，而是**线性**增加，即每经过一个传输轮次只增加1MSS.

无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。 （这是不使用快重传的情况）

快重传：快重传要求接收方在**收到一个失序的报文段后就立即发出重复确认**（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

快恢复：**当发送方连续收到三个重复确认时，就把慢开始门限减半，然后执行拥塞避免算法**。不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。 也有的快重传是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3*MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络的资源而是停留在接收方的缓存中。可见现在网络中减少了三个分组。因此可以适当把拥塞窗口扩大些。

<center>
<img src="https://img-blog.csdnimg.cn/310370832bca4df9b4c74df222285c76.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rlc3RpbnlfemM=,size_16,color_FFFFFF,t_70"></img>

</center>

---

### 5、为什么是3次握手?
因为TCP协议是全双工通信协议,也就是说,TCP在进行数据传输时,两端都可以同时进行发送和接受数据,所以,在进行连接时,两端都要进行对环路的检测,首先客户端发起连接请求,在接收到应答后,客户端才可以确定环路通畅,可以进行数据 发送,服务端同样要进行检测,所以,服务端也要进行请求,并接收应答,在第二次握手时,将服务端的应答和请求压缩为一个数据包,所以需要进行3次握手,而2次不足以完成连接,4次则又多余,浪费资源.

---

### 6、为什么是4次挥手?
4次挥手是因为主动发起方首先要进行发起关闭请求,被动方收到后,要立即回复一个应答包,之后检测被动端数据是否发送完毕(发送完毕并且受到接收应答),在确认发送完毕后才会发起一个确认关闭请求,等待最后一个应答包,当主动方受到被动方发送的确认关闭请求时,会发送一个应答包,并进入TIME_WAIT状态,经过2MSL之后断开连接,被动方受到应答包之后直接进入关闭状态并释放资源.为什么关闭时应答包和请求关闭包不能合并,因为关闭时,主动方并不知道被动方数据是否已经发送完毕,被动方要检测所有数据发送完毕后才进行关闭请求.

---

### 7、为什么要进入TIME_WAIT状态等待2MSL?
* 第四次挥手后为什么要经过TIME_WAIT状态之后才进入CLOSED状态，为什么不直接进入CLOSED状态？

因为客户端发送的第四次挥手的ACK应答数据包，服务端可能没有收到，如果服务端在发送第三次挥手的FIN数据包后，等待一段时间后没有收到ACK应答，那么会重新发送第三次挥手的FIN数据包，客户端收到后再次发送第四次挥手的ACK数据包。
这TIME_WAIT状态的等待时间就是为了防止服务端没有收到客户端发送的第四次挥手的ACK数据包，从而向客户端重新发送第三次挥手的FIN数据包时，客户端能正常接收到FIN数据包并且向服务端发送第四次挥手的ACK应答数据包。

* TIME_WAIT状态为什么是2MSL的时长？为什么不是等待其他时长？

MSL，Maximum Segment Lifetime，最大报文段生存时间。即任何TCP报文在网络中存在的最大时长，如果超过这个时间，这个TCP报文就会被丢弃。2MSL，即两个最大报文段生存时间。
因为客户端不知道服务端是否能收到ACK应答数据包，服务端如果没有收到ACK，会进行重传FIN，考虑最坏的一种情况：第四次挥手的ACK包的最大生存时长(MSL)+服务端重传的FIN包的最大生存时长(MSL)=2MSL。

* 如果客户端不经过2MSL时长的TIME_WAIT状态，发送ACK之后就立马关闭TCP链接，释放端口号和内存资源，会出现什么情况？
 
可能会出现服务端并没有收到`ACK`，然后重新发送第三次挥手的`FIN`包，而此时客户端又新建了到服务端的`TCP`链接，并且客户端使用的还是之前的端口号，那么网络中延迟到达的`FIN`包就会被这个新的`TCP`链接接收到，这不是客户端希望接收到的数据，因此要等待`2MSL`的时长，确保网络中的`FIN`包全都不存在了，才关闭`TCP`链接，释放端口号和内存资源，这个时候客户端就可以重新使用这个端口号连接任何服务器，包括刚断开的这台服务器。
因此，TIME_WAIT状态需要等待2MSL的时长，确保本次TCP连接的四次挥手的关闭流程的正确可靠。
总结，TIME_WAIT状态的时长设置为2MSL的主要原因：

* 确保被动关闭TCP连接的一端能收到第四次挥手的ACK
* 避免上一次TCP连接的数据包影响到下一次的TCP连接。

---

### 8、TCP协议握手时是否可以携带数据,可以在第几次握手时携带?
可以携带数据,可以在第三次携带,因为第三次握手时,若到达服务端,则表示连接无误,数据也自然可以到达服务端,若是未到达服务端,则表示连接失败,则不可以发送数据.第一次和第二次握手都不可以携带数据,因为第一次和第二次握手成功之后都不可以保证连接无误,若此时携带数据,则会破坏TCP协议的连接特性.
TCP协议虽然有很多优点,但是也有一个最致命的缺点,那就是传输速度慢,在进行了大量的可靠传输保证中消耗了很多性能,所以传输速率非常慢,在以后与UDP的对比中会越发明显；

---

### 9、第三次握手中，如果客户端的ACK未送达服务器，会怎样？
Server端： 由于Server没有收到ACK确认，因此会重发之前的SYN+ACK（默认重发五次，之后自动关闭连接进入CLOSED状态），Client收到后会重新传ACK给Server。

---

### 10、如果已经建立了连接，但客户端出现了故障怎么办？
服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个**探测报文段**，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

---

### 11、初始序列号是什么？
TCP连接的一方A，**随机**选择一个32位的序列号（Sequence Number）作为发送数据的初始序列号（Initial Sequence Number，ISN），比如为1000，以该序列号为原点，对要传送的数据进行编号：1001、1002...三次握手时，把这个初始序列号传送给另一方B，**以便在传输数据时，B可以确认什么样的数据编号是合法的**；同时在进行数据传输时，A还可以确认B收到的每一个字节，如果A收到了B的确认编号（acknowledge number）是2001，就说明编号为1001-2000的数据已经被B成功接受。

---

### 12、初始序列号为什么是随机的？

数据安全，假如现在有客户端A和服务器B和假冒客户端C,假冒客户端请求连接服务器发送一个序列`ISC_C`，此时服务端会与客户端发送确认消息`ack=ISN_C+1`！=客户端A发送的序列号ISN_A的确认消息`ack=ISN_A+1`,此时客户端会与服务端断开连接。

---

### 13、为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？
因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。

---

### 14、如果第二次挥手时服务器的ACK没有送达客户端，会怎样？
客户端没有收到ACK确认，会重新发送FIN请求。

---

### 15、TCP与UDP的区别
1. TCP是面向连接的，UDP是无连接的；（UDP发送数据之前不需要建立连接）
2. TCP是可靠的，UDP不可靠；（UDP接收方收到报文后，不需要给出任何确认）
3. TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；
4. TCP是面向字节流的，UDP是面向报文的；（面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。）
5. TCP有拥塞控制机制，UDP没有。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏；
6. TCP首部开销（20字节）比UDP首部开销（8字节）要大
7. UDP 的主机不需要维持复杂的连接状态表

---

### 16、什么时候选择TCP，什么时候选UDP？

对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失

---

### 17、HTTP可以使用UDP吗？
HTTP不可以使用UDP，HTTP需要基于可靠的传输协议，而UDP不可靠

---
### 18、面向连接和无连接的区别

无连接的网络服务（数据报服务）-- 面向连接的网络服务（虚电路服务）

虚电路服务：首先建立连接，所有的数据包经过相同的路径，服务质量有较好的保证；

数据报服务：每个数据包含目的地址，数据路由相互独立（路径可能变化）；网络尽最大努力交付数据，但不保证不丢失、不保证先后顺序、不保证在时限内交付；网络发生拥塞时，可能会将一些分组丢弃；

---
### 19、TCP如何保证传输的可靠性
1. 数据包校验
2. 对失序数据包重新排序（TCP报文具有序列号）
3. 丢弃重复数据
4. 应答机制：接收方收到数据之后，会发送一个确认（通常延迟几分之一秒）；
5. 超时重发：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据；
6. 流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出

---

### 20、UDP实现可靠传输

(1)将实现放到应用层，然后类似于TCP，实现`确认机制、重传机制和窗口确认机制`；
(2)给数据包进行编号，按顺序接收并存储，接收端收到数据包后发送确认信息给发送端，发送端接收到确认信息后继续发送，若接收端接收的数据不是期望的顺序编号，则要求重发；（主要解决丢包和包无序的问题）

---

## 6、 HTTP:
（HyperText Transport Protocol）是超文本传输协议的缩写，它用于传送WWW方式的数据，关于HTTP协议的详细内容请参考RFC2616。HTTP协议采用了请求/响应模型。

---
### 1、Http的报文结构。

（1）HTTP请求报文
一个HTTP请求报文由`请求行`、`请求头部`、`空行`和`请求数据`4个部分组成；
（2）HTTP响应报文
一个HTTP响应报文由三个部分组成，分别是：`状态行`、`消息报头`、`响应正文`。

---
### 2、HTTP与HTTPS有什么区别？


HTTP具有以下的安全漏洞:
1. 容易被监听
    http通信都是明文，数据在客户端与服务器通信过程中，任何一点都可能被劫持。比如，发送了银行卡号和密码，hacker劫取到数据，就能看到卡号和密码，这是很危险的
2. 被伪装
    http通信时，无法保证通行双方是合法的，通信方可能是伪装的。比如你请求`www.taobao.com`,你怎么知道返回的数据就是来自淘宝，中间人可能返回数据伪装成淘宝。
3. 被篡改
    hacker中间篡改数据后，接收方并不知道数据已经被更改

证书的内容包括：电子签证机关的信息、公钥用户信息、公钥、权威机构的签字和有效期等等。


`HTTP`协议传输的数据都是`未加密`的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。

简单来说，`HTTPS`协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

<center>
<img src="https://img-blog.csdnimg.cn/718e1432aff143f48d680b6138ad32e5.jpg
"width="50%" height="50%"></img>
</center>

如上图所示 HTTPS 相比 HTTP 多了一层 SSL/TLS
`SSL`（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持.`TLS`（Transport Layer Security，传输层安全.

>[此部分参考腾讯云:辉哥](https://cloud.tencent.com/developer/article/1425339#:~:text=HTTPS%EF%BC%88%E5%85%A8%E7%A7%B0%EF%BC%9AHyper%20Text%20Transfer%20Protocol%20over%20Secure,Socket%20Layer%20%E6%88%96%20Hypertext%20Transfer%20Protocol%20Secure%EF%BC%8C%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%EF%BC%89%EF%BC%8C%E6%98%AF%E4%BB%A5%E5%AE%89%E5%85%A8%E4%B8%BA%E7%9B%AE%E6%A0%87%E7%9A%84HTTP%E9%80%9A%E9%81%93%EF%BC%8C%E7%AE%80%E5%8D%95%E8%AE%B2%E6%98%AFHTTP%E7%9A%84%E5%AE%89%E5%85%A8%E7%89%88%E3%80%82)
---

`HTTPS`和`HTTP`的区别主要如下：

1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
PING (Packet Internet Groper)，因特网包探索器，用于测试网络连通性的程序。

---
### 3、Ping，ICMP报文是什么。
Ping发送一个`ICMP`(Internet Control Messages Protocol,因特网信报控制协议)；回声请求消息给目的地并报告是否收到所希望的`ICMPecho` （ICMP回声应答）。
工作原理：利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通，延时是多少。
为了提高IP数据报交付成功机会，在网络层使用过了网际控制报文协议（`ICMP`）来允许主机或路由器报告差错和异常情况。`ICMP`报文作为IP层数据报的数据，加上数据报首部，组成IP数据报发出去。`ICMP`协议是IP层协议。

---

### 4、http1.0与http1.1的区别
1、HTTP 1.0中浏览器与服务器只保持短暂的连接，浏览器的每次请求都与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。

2、http1.1提供永久性连接（即1.0使用非持久连接，HTTP1.0没有host的字段).

3、HTTP 1.1中增加Host请求头字段后，实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。

4、http1.1提供身份认证（HTTP1.1提供一个基于口令的基本认证方式）

---
### 5、http 状态码

|分类|分类描述|
|---|---|
|1xx|信息，服务器收到请求，需要请求者继续执行操作|
|2xx|成功，操作成功接受并被处理|
|3xx|重定向，需要进一步操作以完成请求|
|4xx|客户端错误，请求包含语法错误或无法完成请求|
|5xx|服务器错误，服务器在处理请求的过程中发生错误|

---

## 7.keepalive 是什么东西？如何使用？
keepalive，是在TCP中一个可以检测死连接的机制。
1. 如果主机可达，对方就会响应ACK应答，就认为是存活的。
2. 如果可达，但应用程序退出，对方就发RST应答，发送TCP撤消连接。
3. 如果可达，但应用程序崩溃，对方就发FIN消息。
4. 如果对方主机不响应ack, rst，继续发送直到超时，就撤消连接。默认二个小时。

---

## 8. udp调用connect有什么作用？

1. 因为UDP可以是一对一，多对一，一对多，或者多对多的通信，所以每次调用sendto()/recvfrom()时都必须指定目标IP和端口号。通过调用connect()建立一个端到端的连接，就可以和TCP一样使用send()/recv()传递数据，而不需要每次都指定目标IP和端口号。但是它和TCP不同的是它没有三次握手的过程。

2. 可以通过在已建立连接的UDP套接字上，调用connect()实现指定新的IP地址和端口号以及断开连接。

---

## 9. IP 层怎么知道报文该给哪个应用程序,它怎么区分 UDP 报文还是 TCP 报文
区分应用程序是根据端口进行区分;
区分 UDP 报文还是 TCP 报文是-->看 ip 头中的协议标识字段,17 是 udp,6 是 tcp;
