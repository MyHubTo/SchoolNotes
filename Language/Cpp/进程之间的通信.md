[TOC]
## 1.进程之间的通信
* 无名管道
* 有名管道
* 消息队列
* 共享内存
* 信号量
在看进程之间的通信之前先看一下进程创建与继承关系[进程创建与继承关系](https://subingwen.cn/linux/process/#1-%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0)

---
* <font color=blue>CPU 时间片</font>
CPU 在某个时间点只能处理一个任务，但是操作系统都支持多任务的，那么在计算机 CPU 只有一个和的情况下是怎么完成多任务处理的呢？原理和古时候救济灾民的思路是一样的，每个人分一点，但是又不叫吃饱。

<font color=blue>CPU 会给每个进程被分配一个时间段，进程得到这个时间片之后才可以运行，使各个程序从表面上看是同时进行的。</font> <font color =red>如果在时间片结束时进程还在运行，CPU 的 使用权 将被收回，该进程将会被中断挂起等待下一个时间片。如果进程在时间片结束前阻塞或结束，则 CPU 当即进行切换，这样就可以避免 CPU 资源的浪费。</font >

因此可以得知，在我们使用的计算机中启动的多个程序，从宏观上看是同时运行的，从微观上看由于 CPU 一次只能处理一个进程，所有它们是轮流执行的，只不过切换速度太快，我们感觉不到罢了，因此 CPU 的核数越多计算机的处理效率越高。

>作者: 苏丙榅
>链接: https://subingwen.cn/linux/process/#1-%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0
>来源: 爱编程的大丙

<center>
<img src="https://img-blog.csdnimg.cn/187598420c3841e5895f39729a94ce7b.png"  style="zoom: 15%;" />
</center>

**创建状态**：进程在创建时需要申请一个空白PCB(进程控制块)，向其中填写**控制和管理进程**的信息，完成**资源分配**。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态;
**就绪状态**：CPU 时间片
  * 进程被创建出来了，有运行的资格但是还没有运行，需要抢 CPU 时间片
  * 得到 CPU 时间片，进程开始运行，从就绪态转换为运行态。
  * 进程的 CPU 时间片用完了，再次失去 CPU, 从运行态转换为就绪态。
  
**执行状态**：获取到 CPU 资源的进程，进程只有在这种状态下才能运行;

  * 运行态不会一直持续，进程的 CPU 时间片用完之后，再次失去 CPU，从运行态转换为就绪态
  * 只要进程还没有退出，就会在就绪态和运行态之间不停的切换。

**阻塞状态**：进程被强制放弃 CPU，并且没有抢夺 CPU 时间片的资格;

  * 比如：在程序中调用了某些函数（比如: sleep ()），进程又运行态转换为阻塞态（挂起态）
  * 当某些条件被满足了（比如：slee () 睡醒了），进程的阻塞状态也就被解除了，进程从阻塞态转换为就绪态。

**终止状态**：进程被销毁，占用的系统资源被释放了
  * 任何状态的进程都可以直接转换为退出态。


> 如果进程运行时间片使用完也会进入就绪状态。
> 另外为用户观察需要，进程还有**挂起**和**激活**两种操作。挂起后进程处于静止状态进程不再被系统调用，对于操作是激活操作。
---

### 1.无名管道
#### 1.1 无名管道的通信原理
具体来说就是**内核**会开辟一个“管道”，通信的进程通过共享这个管道，从而实现通信；
1. 管道又是什么呢？
由于内核也是运行在物理内存上，内核创建一个管道，其实就是在内核所在的物理内存空间中开辟一段缓存空间，由于进程之间的通信；
2. 如何操作管道？
以文件的方式来读写管道，以文件放回来操作时：
 * 有读写用的文件描述符
 * 读写时会用write、read等文件IO函数；
3. 为什么叫无名管道？
既然可以通过“文件描述符”来操作管道，那么他就是一个文件（管道文件），但是无名管道文件比较特殊，他没有文件名，正是由于没有文件名，所以称为无名管道；
#### 1.2 无名管道的API
##### 1.2.1 函数原型
```cpp
#include <unistd.h>
int pip(int pipfd[2]);
```
> 功能：创建一个用于亲缘进程（父子进程）之间通信的无名管道（缓存），并将管道与两个文件描述符关联起来。
> 参数： 缓存地址，用于存放读写管道的文件描述符（int pipfd[2]）；
>   * 元素[0]:读管道的读文件描述符；
>   * 元素[1]:写管道的写文件描述符；
>   * 返回值：成功返回0，失败返回-1；
4. 为什么无名管道只能用于亲缘进程之间的通信？
   由于没有文件描述符，因此进程没办法使用open打开管道，从而得到文件描述符，所以只有通过父进程调用`pipe()`创建出管道，并得到读写管道的文件描述符，然后在`fork()`出子进程，让子进程通过继成父进程打开的文件描述符，父子进程就能操作同一个管道，从而实现通信。
##### 1.2.2 父子进程单向通信
1. 实现步骤：
    1. 父进程在`fork()`之前先调用`pipe()`创建无名管道，并获取读、写文件描述符；
    2. `fork()`创建子进程，子进程继承无名管道读、写文件描述符；
    3. 父子进程使用各自管道的读写文件描述符进行读写操作，实现通信；
    4. 关闭不使用的文件描述符；
<center>
<img src="https://img-blog.csdnimg.cn/f740bcc976d5457fb140eebc9efacacf.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGVzdGlueV96Yw==,size_20,color_FFFFFF,t_70,g_se,x_16" width="70%" height="70%"></img>
</center>

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <list>
#include <unistd.h>
#include <mutex>
extern "C"
{
    #include <string.h>
}
using namespace std;
int main()
{
    int ret=0;
    //[0]:读文件描述符；
    //[1]:写文件描述符；
    int pipefd[2]={0};//用于存储管道的读写文件描述符

    ret=pipe(pipefd);//创建管道，获取文件描述符；

    ret=fork(); //创建子进程
    if(-1==ret)
    {
        cout<<"管道创建失败，退出！"<<endl;
        exit(-1);
    }

    //ret :会有两个值，一个是父进程返回，一个是子进程返回；
    if(ret>0)//表明是进程，返回进程的PID;
    {
        int i=0;
        close(pipefd[0]);//关闭父进程的读文件描述符；
        while(true)
        {
            string info=to_string(++i);
            const char *buff=info.c_str();
            write(pipefd[1],buff,strlen(buff));
            cout<<"父进程发送数据："<<buff<<endl;
            sleep(1);
        }
    }
    else if(0==ret)//表明是子进程；
    {
        close(pipefd[1]);//关闭子进程的写文件描述符；
        while (true)
        {
            char buff[100]={0};
            read(pipefd[0],buff,sizeof(buff));
            cout<<"子进程收到数据："<<buff<<endl;
            
        }
        
    }
    return 0;
}
```
2. SIGPIPE信号：
    1. 什么时候产生这个信号？
        写管道时，如果管道的`所有读端被close`了话，向管道写数据的进程会被内核发送一个SIGPIPE信号，通知用户所有的读端都被关闭；
        这个信号的**默认动作是终止**，所以收到这个信号的进程就会被终止，如果不想被终止进程，可以“忽略、捕获、屏蔽”这个信号；

>tip:SIGPIPE信号,只有当所有读端被关闭时才产生SIGPIPE信号信号，有一个打开，都不会产生SIGPIPE信号信号；

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <list>
#include <unistd.h>
#include <mutex>
#include <signal.h>
extern "C"
{
    #include <string.h>
}
using namespace std;
int main()
{
    int ret=0;
    //[0]:读文件描述符；
    //[1]:写文件描述符；
    int pipefd[2]={0};//用于存储管道的读写文件描述符

    ret=pipe(pipefd);//创建管道，获取文件描述符；

    ret=fork(); //创建子进程
    if(-1==ret)
    {
        cout<<"管道创建失败，退出！"<<endl;
        exit(-1);
    }

    //ret :会有两个值，一个是父进程返回，一个是子进程返回；
    if(ret>0)//表明是进程，返回进程的PID;
    {
        //signal(SIGPIPE,SIG_IGN);//!忽略SIGPIPE信号；
        int i=0;
        close(pipefd[0]);//关闭父进程的读文件描述符；
        while(true)
        {
            string info=to_string(++i);
            const char *buff=info.c_str();
            write(pipefd[1],buff,strlen(buff));
            cout<<"父进程发送数据："<<buff<<endl;
            sleep(1);
        }
    }
    else if(0==ret)//表明是子进程；
    {
        close(pipefd[1]);//关闭子进程的写文件描述符；
        //close(pipefd[0]);//!关闭子进程的读文件描述符；--> SIGPIPE信号
        while (true)
        {
            char buff[100]={0};
            read(pipefd[0],buff,sizeof(buff));
            cout<<"子进程收到数据："<<buff<<endl;
            
        }
        
    }
    return 0;
}
```
##### 1.2.3 父子进程双向通信
1. 单个无名管道无法实现双向通信，为什么？
   因为使用单个无名管道来实现双向通信时，自己发送给对方的数据，会被自己读取到；
2. 如何实现无名管道的双向通信？
   使用两个无名管道，每个管道负责一个方向的通信；
### 2.有名管道
#### 2.1 为什么叫"有名管道“
无名管道因为没有文件名，被称为了无名管道，同样的道理，有名管道之所以叫"有名管道"，因为它有文件名。也就是说当我们调用相应的`API`创建好”有名管道“后，会在相应的路径下面看到一个叫某某名字的“有名管道文件"。不管是有名管道，还是无名管道，它们的本质其实都是一样的，它们都是内核所开辟的一段缓存空间。进程间通过管道通信时，本质上就是通过共享操作这段缓存来实现，只不过操作这段缓存的方式，是**以读写文件**的形式来操作的。

#### 2.2 有名管道特点
##### 2·2·1 能够用于非亲缘进程之间的通信
因为有文件名，所以进程可以直接调用`open函数`打开文件，从而得到文件描述符，不需要像无名管道一样，必须在通过继承的方式才能获取文件描述符。所以任何两个进程之间，如果想要通过"有名管道“来通信的话，不管它们是`亲缘`的还是`非亲缘`的，只要调用`open函数`打开同一个"有名管道"文件，然后对同一个"有名管道文件"进行读写操作，即可实现通信。

<center>A进程-->有名管道-->B进程</center>

总之，不管是亲缘进程还是非亲缘进程，都可以使用有名管道来通信
> 1. 读管道时，如果管道没有数据的话，读操作同样会阻塞（休眠）
> 2. 当进程写一个所有读端都关闭的管道时，进程会被内核返回来的SIGPIPE信号终止，如果不想被这个信号终止，可以选择“忽略、捕获、屏蔽该信号”；
#### 2.3 有名管道的使用步骤
   1. 进程调用`mkfifo()`创建有名管道；
   2. `open()`打开有名管道；
   3. `read/write()`读写管道进行通信；
对于通信的两个进程来说，创建管道时，只需要方创建，另一个直接使用即可；
为了保证管道一定被创建，最好是两个进程包含创建管道的代码，哪一个进程先运行就先创建，后运行的发现管道已经创建好了，那就直接`open()`打开使用；
#### 2.4 有名管道API
##### 2.4.1 函数原型
```cpp
#include<sys/types.h>
#include<sys/stat.h>
int mkfifo(const char *pathname,mode_t mode);
```
> 1. 功能：创建有名管道文件，创建好后便可以使用`open()`打开；
> 如果是创建普通文件的话，我们可以使用`open()`的`O_CREAT`项来创建，比如：
> open("./file",O_RDWR|O_CREAT,0664);
> 但是对于“有名管道”这种特殊文件，这里只能使用`mkfifo`函数来创建；
> 2. 参数：
> pathname:被创建管道文件的文件路径名；
> mode:指定被创建时**原始权限**，一般为**0664(110110100)**,必须包含读写权限。
> 使用`open()`函数创建普通文件时，指定原始权限是一样；
> mkfifo("./file",0664);
> 3. 返回值：成功返回0，失败返回-1；

##### 2.4.2 有名管道单向通信
```cpp
//write.c   写进程
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>

int creatFifo(const char *fifoname,int open_mode)
{
    int ret=-1,fd=-1;
    ret= mkfifo(fifoname, 0664);//0664,打开原始状态码。
    if(ret==-1&&errno!=EEXIST) //!errno!=EEXIST:忽略文件存在的报错信息；
    {
       printf("mkfifo error");
        exit(-1);
    }
    
    fd =open(fifoname,open_mode);//以只写的方式打开文件；
                                    //!此处可能会发生阻塞！！！
                                    //!对于管道而言，如果以只写的方式打开管道，而管道的没有打开读端，就会堵塞；
    if(fd==-1)
    {
        printf("open error");
        exit(-1);
    }

    return fd;
}
void deletFifoFile(int signal)
{
    remove("./mfifo");
}
int main()
{
    int ret=-1;
    int fd =-1;

    char buff[100];
    const char *pathname="./mfifo";

    signal(SIGINT,deletFifoFile);//使用中断信号，调用deletFifoFile，在程序中断时，删除mfifo;
    
    fd=creatFifo(pathname,O_WRONLY);//fd文件描述符
    
    while (1)
    {
        scanf("%s",buff);
        write(fd,buff,sizeof(buff));
    }
    return 0;
}
```
```cpp
//read.c    读进程
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>

int creatFifo(const char *fifoname,int open_mode)
{
    int ret=-1,fd=-1;
    
    ret= mkfifo(fifoname, 0664);//0664,打开原始状态码。
    if(ret==-1&&errno!=EEXIST) //!errno!=EEXIST:忽略文件存在的报错信息；
    {
       printf("mkfifo error");
        exit(-1);
    }
  
    fd =open(fifoname,open_mode);//以只写的方式打开文件；
 
    if(fd==-1)
    {
 
 	printf("open error!");
        exit(-1);
    }
    return fd;
}
void deletFifoFile(int signal)
{
    remove("./mfifo");
}
int main()
{
    int ret=-1;
    int fd =-1;

    char buff[100]={0};
    const char *pathname="./mfifo";

    signal(SIGINT,deletFifoFile);//使用中断信号，调用deletFifoFile，在程序中断时，删除mfifo;
    
    fd=creatFifo(pathname,O_RDONLY);//fd文件描述符
    
    while (1)
    {
        read(fd,buff,sizeof(buff));
        printf("recv:%s\n",buff);
    }
    return 0;
}
```
##### 2.4.3 有名管道双向通信
1. 使用一个有名管道是不能实现双向通信，与无名管道相同，存在自己的读端会抢到数据；
2. 与无名管道相似，采用两个管道，进行双向通信；

### 3.system V IPC(进程间通信)
system V IPC 是第五版进程间通信，在之前的无名管道与有名管道后增加了三种进程之间的通信机制：
* 消息队列
* 共享内存
* 信号量
  
1. 管道
管道的本质就是一段缓存，不过Linux os内核是以文件的形式来管理的，所以我们操作管道时，不管是无名管道，还是有名管道，我们都是使用文件描述符以文件的形式来操作的

2. System V IPC
System V IPC与管道有所不同，它完全使用了不同的实现机制，与文件没任何的关系，也就是说内核不再以文件的形式来管理System V IPC，所以不能再使用文件的方式来操作。
3. System V IPC标识符
我们前面说过，System V IPC不再以文件的形式存在，因此没有文件描述符这个东西，但是它有类似的**标识符**。
你完全可以认为这个“标识符”就是文件描述符的替代者，但是它是专门给System V IPC使用的，所以我们不能使用文件IO函数来操作“标识符”，只能使用System V IPC的特有API才能操作。
   1.  怎么才能得到这个“表示符”
调用某API创建好某个“通信结构”以后，API就会返回一个唯一的“标识符”。
比如创建好了一个“消息队列”后，创建的API就会返回一个唯一标识消息队列的“标识符”。
   2. System V IPC 表示符的作用？
比如，如果创建的是消息队列的话，进程通过消息队列唯一的标识符，就能找到创建好的**消息队列**，使用这个消息队列，进程就能读取数据，然后实现进程间的通信；

### 3.System V IPC -消息队列

#### 3.1.消息队列的原理

1. 消息队列的本质

消息队列的本质就是由**内核创建的用于存放消息的链表**，由于是存放消息的，所以我们就把这个链表称为了消息队列。通信的进程通过共享操作同一个消息队列，就能实现进程间通信。

2. 消息是如何存放在消息队列中的呢？

消息队列这个链表有很多的节点，链表上的每一个节点就是一个消息。

从图中可以看出，每个消息由两部分组成，分别是**消息编号（消息类型）和消息正文**。
    1）**消息编号**：识别消息用
    2）**消息正文**：真正的信息内容
3. 收发数据的过程
1. 发送消息
   
**1). 进程先封装一个消息包**
这个消息包其实就是如下类型的一个结构体变量，封包时将消息编号和消息正文写到结构体的成员中。
```cpp
    struct msgbuf {
    long mtype;／*放消息编号，必须＞0*／
    char mtext[msgsz];／＊消息内容（消息正文）＊／}
```
    
**2).调用相应的API发送消息**

调用API时通过“消息队列的标识符”找到对应的消息队列，然后将消息包发送给消息队列，消息包（存放消息的结构体变量）会被作为一个链表节点插入链表。

2. 接收消息
    调用API接收消息时，必须传递两个重要的信息
       1. 消息队列标识符
       2. 你要接收消息的编号
        有了这两个信息，API就可以找到对应的消息队列，然后从消息队列中取出你所要编号的消息，如此就收到了别人所发送的信息。

“消息队列”有点像信息公告牌，发送信息的人把某编号的消息挂到公告牌上，接收消息的人自己到公告牌上去取对应编号的消息，如此，发送者和接受者之间就实现了通信。

3. 使用消息队列实现网状交叉通信

对于前面讲的管道来说，很难实现网状交叉通信，但是使用消息队列确非常容易实现.比如现在有4个进程，分别为A,B,C,D，其消息队列编号分别为：1,2，3,4；
假如线程A想向线程C进行通信，则只需要将消息封装，消息编号设为C进程对应的编号3，加入到消息队列中，就可以实现AC之间的通信；

4. 消息队列的使用步骤
   1. 使用`msgget函数`创建新的消息队列、或者获取己存在的某个消息队列，并返回唯一标识消息队列的**标识符(msqID）**，后续收发消息就是使用这个标识符来实现的。
   2. 收发消息
      * 发送消息：使用`msgsnd函数`，利用消息队列标识符发送某编号的消息
      * 接收消息：使用`msgrcv函数`，利用消息队列标识符接收某编号的消息
   3. 使用`msgc函数`，利用消息队列标识符删除消息队列

对于使用消息队列来通信的多个进程来说，**只需要一个进程来创建消息队列就可以了**，对于其它要参与通信的进程来说，直接使用这个创建好的消息列即可。

为了保证消息队列的创建，最好是让每一个进程都包含创建消息队列的代码，谁先运行就由谁创建，后运行的进程如果发现它想用的那个消息队列己经创建好了，就直接使用，当众多进程共享操作同一个消息队列时，即可实现进程间的通信。
<center>
<img src="https://img-blog.csdnimg.cn/a430115d429d49b18b9fc1234545ad77.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGVzdGlueV96Yw==,size_20,color_FFFFFF,t_70,g_se,x_16" width="70%" height="70%"></img>
</center>

#### 3.1.消息队列API
1. 函数原型
```cpp
#include<sys/types.h>
#include<sys/ipc.h>
#include<sys/msg.h>
int msgget(keytkey,intmsgflg);
```
> 1. 功能：利用key值创建、或者获取一个消息队列。

   * 如果key没有对应任何消息队列，那就创建一个新的消息队列
   * 如果key己经对应了某个消息队列，说明你要的消息队列己经存在了，那就获取这个消息队列来使用.
> 2. 返回值

   * 成功：返回消息队列标识符（消息队列的ID）对于每一个创建好的消息队列来说，ID是固定的。
   * 失败：失败返回一1，并设置errno.
> 3. 参数
   1. key值
    用于为消息队列生成（计算出）唯一的消息队列ID。我们可以指定三种形式的key值：
      1. 指定为PPRIVATE宏，指定这个宏后，每次调用`msgget`时都会创建一个新的消息队列。
        如果你每次使用的必须是新消息队列的话，就可以指定这个，不过这个用的很少。因为一般来说，只要有一个消息队列可以用来相信就可以了，并不需要每次都使用全新的消息队列。

      2. 第二种：可以自己指定一个整形数，但是容易重复指定
        本来我想创建一个新的消息队列，结果我所指定的这个整形数，之前就己经被用于创建某个消息队列了，当我的指定重复时，`msgget`就不会创建新消息队列，而是使用的是别人之前就创建好的消息队列。所以我们也不会使用这种方式来指定key值。

      3. 利用`ftok`函数来生成key
```cpp
    #include <sys/types.h>
    #include <sys/ipc.h>
    key_t ftok(const char *pathname, int proj_id);
```
ftok通过指定的路径名和一个整型数，就可以计算并返回一个唯一对应的key值，只要路径名和整型数不变，所对应的key值就唯一不变。

不过由于ftok只会使用整型数（proj_id)的低8位，因此我们往往会指定为一个`ASCII`码值，因为ASCII码值刚好对应是8位的整型数；

2. msgflg:
指定创建时的原始权限，比如0664；
创建一个新的队列消息时，除了原始权限，还需要指定IPC_CREAT选项。

```cpp
msgid=msgget(key,0664|IPC_CREAT)
```

如果key值没有对应任何消息队列，就会创建一个新的消息队列，此时就会使用msgflg参数，但是如果key已经对应了一个已经存在的消息队列，就直接返回这个已存在的消息队列的ID（标识符），此时不会用到msgflg.

4. 多个进程是如何共享到同一个消息队列的
    1. 创建进程
    如果创建者使用“．/file",'a'生成一个key值，然后调用msgget创建了一个消息队列，比如：
    ```cpp
    key=ftok（"./file",'a');
    msgid=msgget(key,0664丨IPC_CREAT）；
    ```
    当创建者得到msg后，即可以操作消息队列。
    2. 其它共享操作消息队列的进程
    共享的方法很简单，只要你能拿到别人创建好的消息队列的ID，即可共享操作同一个消息队列，实现进程间通信。
    获取别人创建好的消息队列的ID，有两个方法：

       1. 创建者把ID保有到**某文件**，共享进程读出ID即可
        这种情况下，共享进程根本不需要调用`msgget`函数来返回ID。
       2. 调用`msgget`上获取己存在消息队列的ID
        * 使用`ftok`函数，利用与创者**相同的“路径名"和8位整形数**，生成相同的key值；
        * 调用`msgget`函数，利用key找到别人创建好的消息队列，返回ID
        ```cpp
        key=ftok("./file"
        msgid=msgget（key,0664|IPC_CREAT);
        ```
    拿到了消息队列的ID后就能共享操作了。
    这种方法是最常用的方法，因为地。k所用到的“路名“和位的整形数"比较好记忆，所以，你只要记住别人生成key值时所用的“路径名“和位的整形数“，你就一定能共享操作别人创建好的消息队列。

### 4. System V IPC -共享内存
#### 4.1 共享内存
共享内存就是os在物理内存中开辟一大段缓存空间，不过与管道、消息队列调用`read、write、msgrcv`等API来读写所不同的是，使用共享内存通信时，进程是**直接使用地址来共享读写的**。
当然不管使用那种方式，只要能够共享操作同一段缓存，就都可以实现进程间的通信。

不过如果**直接使用地址来读写缓存时，效率会更高**，但是如果是调用API来读写的话，中间必须经过重重的`OS`函数调用之后，直到调用到最后一个函数时，该数才会通过地址去读写共享的缓存，中间的调用过程会降低效率。

对于小数据量的通信来说，使用管道和消息队列这种API读写的通信方式很合适，但是如果进程涉及到超大量的数据通信时，必须使用”共享内存“这种直接使用地址操作的通信方式，如果使用API来读写的话，效率会非常的低。


#### 4.2 共享内存的原理
每个进程的虚拟内存只严格对应自己的那片物理内存空间，也就是说虚拟空间的虚拟地址，只和自己的那片物理内存空间的物理地址建立映射关系，和其它进程的物理内存空间没有任何的交集，因此进程空间之间是完全独立的。

共享内存的实现原理很简单，以两个进程使用共享内存来通信为例，实现的方法就是：
1. 调用API，让os在物理内存上开辟出一大段缓存空间。
2. 让各自进程空间与开辟出的缓存空间**建立映射**关系

就让虚拟地址和物理内存的实际物理地址建立一对一的对应关系，使用虚拟地址读写缓存时，虚拟地址最终是要转为物理地址的，转换时就必须参考这个映射关系。总之建立映射关系后，每个进程都可以通过映射后的虚拟地址来共享操作实现通信了。

#### 4.3 共享内存的使用步骤
   1. 进程调用`shmget`函数创建新的或获取己有共享内存`shm`是`sharememory`的缩写.
   2. 进程调用`shmat`函数，将物理内存映射到自己的进程空间;说白了就是让虚拟地址和真实物理地址建议一一对应的映射关系。建立映射后，就可以直接使用虚拟地址来读写共享的萨豇存空间了。
   3. 进程调用`shmdt`函数，取消映射
   4. 调用`shmctl`函数释放开辟的那片物理内存空间
多个进程使用共享内存通信时，创建者只需要一个，同样的，一般都是谁先运行谁创建，其它后运行的进程发现己经被创建好了，就直接获取共享使用，大家共享操作同一个内存，即可实现通信。

### 5.5 信号量
#### 5．1 信号量的作用

信号量的作用就是，当多个进程/线程进行共享操作时，说白了就是用于**资源的保护**。
（1）进程信号量
实现的是进程所操作资源的保护。

（2）线程信号量
实现的是线程所操作资源的保护。

#### 5.1.1 什么是进程的资源保护？
用于资源保护，以防止出现相互干扰的情况。

#### 5.1.2 资源保护操作的种类
资源保护的操作分两种，一种叫**互斥**，另一个种叫**同步**。
1. 互斥
对于互斥操作来说，多进程工享操作时，多个进程间不关心谁先操作、谁后操作的先后顺序问题，它们只关心一件事，那就是我操作时别人不能操作。
就算当前正在操作的进程它的时间片到了，切换到了其它进程上，但是当该进程检测到上一个进程还没有操作完时，该进程在当前的时间片内会休眠，直到再次切换会上一个进程，将操作完成后再切换回来，此时才能进行操作。
2. 同步
同步其实本身就**包含了互斥**，不过同步不仅仅只有互斥，**同步对于谁先操作、谁后操作的先后顺序有要求，比如规定A进程先写，然后是B进程写，然后是C进程写，那就绝对不能出现这种操作顺序以外的顺序。**
所以所谓的同步就是，多个进程共享操作时，进程必须要有统一操作的步调，按照一定的顺序来操作。

3. 实现同步、互斥的本质，其实就是加锁
这个很形象，我要操作我就上把锁，在我上锁时只能我操作，你就不能操作，直到我把锁打开了，你才能操作，你燥作时也会加锁，加锁后我就不能燥作了，直到锁打开了。**所以说信号量就是一个加锁机制，通过加锁来实现同步和互斥**。

说到加锁，我们讲到后面”高级IO“时，我们还会讲到”`文件锁`“这个东西，顾思义，文件锁就是专门用来给文件时上锁的.
其实，不管是进程还是线程，都存在同步和互斥的问题，同步和互斥的目的其实就是为了实现"资源”的保护，不要让数据（资源）出现紊乱，**信号量既能实现互斥，也能实现同步**。

4. 信号量这种锁长啥样了？
实物锁大家好理解，不过OS提供的锁就不好理解了，信号量这种OS的锁说白了就是结构体、链表、数组等等数据结构，通过这些数据结构就能标记当前某个某个进程操作完没有，没有操作完的话，当前进程就不能操作，这就实现了加锁的功能。

5. 疑问：信号量既然是一种加锁机制，为什么进程信号量会被归到了进程间通信里面呢？
资源保护时，在某个进程的操作没有完全完成之前，别人是不能操作的，那么进程间须相互知道对方的操作状态，这就必须会涉及到通信的过程。

**所以信号量实现资源的保护的本质就是，通过通信让各个进程了解操作状态，然后查看自己能不能操作**


信号量(semaphore)与已经介绍过的 IPC 结构不同,它是一个计数器,可以用来控制多个进程对共享资源的访问。信号量**用于实现进程间的互斥与同步,而不是用于存储进程间通信数据。**
特点:
1)信号量用于进程间同步,若要在进程间传递数据需要结合共享内存。
2)信号量基于操作系统的 PV 操作,程序对信号量的操作都是原子操作。
3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1,而且可以加减任意正整数。
4)支持信号量组。


