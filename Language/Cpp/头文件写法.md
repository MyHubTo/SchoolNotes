## 1.头文件中应该写什么

头文件的作用就是被其他的 .cpp 包含进去的。它们本身并不参与编译，但实际上，它们的内容却在多个 .cpp 文件中得到了编译。通过"定义只能有一次"的规则，我们很容易可以得出，头文件中应该**只放变量和函数的声明**，而不能放它们的定义。因为一个头文件的内容实际上是会被引入到多个不同的 .cpp 文件中的，并且它们都会被编译。放声明当然没事，如果放了定义，那么也就相当于在多个文件中出现了对于一个符号（变量或函数）的定义，纵然这些定义都是相同的，但对于编译器来说，这样做不合法。

所以，应该记住的一点就是，.h头文件中，只能存在变量或者函数的声明，而不要放定义。即，只能在头文件中写形如：extern int a; 和 void f(); 的句子。这些才是声明。如果写上 inta;或者 void f() {} 这样的句子，那么一旦这个头文件被两个或两个以上的 .cpp 文件包含的话，编译器会立马报错。（关于 extern，前面有讨论过，这里不再讨论定义跟声明的区别了。）

但是，这个规则是有三个例外的:

1. **头文件中可以写 const 对象的定义**。因为全局的 const 对象默认是没有 extern 的声明的，所以它只在当前文件中有效。把这样的对象写进头文件中，即使它被包含到其他多个 .cpp 文件中，这个对象也都只在包含它的那个文件中有效，对其他文件来说是不可见的，所以便不会导致多重定义。同时，因为这些 .cpp 文件中的该对象都是从一个头文件中包含进去的，这样也就保证了这些 .cpp 文件中的这个 const 对象的值是相同的，可谓一举两得。同理，static 对象的定义也可以放进头文件。
2.** 头文件中可以写内联函数（inline）的定义**。因为inline函数是需要编译器在遇到它的地方根据它的定义把它内联展开的，而并非是普通函数那样可以先声明再链接的（内联函数不会链接），所以编译器就需要在编译时看到内联函数的完整定义才行。如果内联函数像普通函数一样只能定义一次的话，这事儿就难办了。因为在一个文件中还好，我可以把内联函数的定义写在最开始，这样可以保证后面使用的时候都可以见到定义；但是，如果我在其他的文件中还使用到了这个函数那怎么办呢？这几乎没什么太好的解决办法，因此 C++ 规定，内联函数可以在程序中定义多次，只要内联函数在一个 .cpp 文件中只出现一次，并且在所有的 .cpp 文件中，这个内联函数的定义是一样的，就能通过编译。那么显然，把内联函数的定义放进一个头文件中是非常明智的做法。   
3. **头文件中可以写类（class）的定义**。因为在程序中创建一个类的对象时，编译器只有在这个类的定义完全可见的情况下，才能知道这个类的对象应该如何布局，所以，关于类的定义的要求，跟内联函数是基本一样的。所以把类的定义放进头文件，在使用到这个类的 .cpp 文件中去包含这个头文件，是一个很好的做法。在这里，值得一提的是，类的定义中包含着数据成员和函数成员。数据成员是要等到具体的对象被创建时才会被定义（分配空间），但函数成员却是需要在一开始就被定义的，这也就是我们通常所说的类的实现。一般，我们的做法是，把类的定义放在头文件中，而把函数成员的实现代码放在一个 .cpp 文件中。这是可以的，也是很好的办法。不过，还有另一种办法。那就是直接把函数成员的实现代码也写进类定义里面。在 C++ 的类中，如果函数成员在类的定义体中被定义，那么编译器会视这个函数为内联的。因此，把函数成员的定义写进类定义体，一起放进头文件中，是合法的。注意一下，如果把函数成员的定义写在类定义的头文件中，而没有写进类定义中，这是不合法的，因为这个函数成员此时就不是内联的了。一旦头文件被两个或两个以上的 .cpp 文件包含，这个函数成员就被重定义了。

## 2.头文件总结：
.h文件中能包含：

    类成员数据的声明，但不能赋值
    类静态数据成员的定义和赋值，但不建议，只是个声明就好。
    类的成员函数的声明
    非类成员函数的声明
    常数的定义：如：constint a=5;
    静态函数的定义
    类的内联函数的定义

不能包含：

    1． 所有非静态变量（不是类的数据成员）的声明
    2。 默认命名空间声明不要放在头文件，using namespace std;等应放在.cpp中，在 .h 文件中使用 std::string

注意：
.h 文件中能包含： static 普通变量和普通函数的定义，但是不能包含，static 成员函数和成员变量的定义。

原因在于 static 这个关键词其实有两个不同的含义：

    static 修饰普通的变量和函数时。
    static 关键字是为了限制可见性。

举例：

void funcA(){ int a =0; a++; printf(a) }，如果要连续记录调用了多少次，就得使用全局变量，但是全局变量暴露的太多了，其他文件中也能可见，所以，static a 用于仅本文件可见。

而 static 修饰类的成员变量时，该成员是属于类本身，所有类的实例对象共享。

class A{
    public:
        static int a;
}

其他文件 include 类定义的头文件 classA.h，本质上相当于复制。假设我们现在不 #include "classA.h" 而是直接写。

例如 a.cpp 写上上述头文件，然后再加上 int A::a = 3;, 在 b.cpp 中写上上述头文件，然后再加上 int A::a = 3;, 等于是定义了两次，此时发生重定义问题（根源在于 static 成员变量并不限制仅本文件可见），所以头文件中不能包含，static 成员函数和成员变量的定义，只能声明。

## 3.头文件定义格式
```cpp
#ifndef  Name
#define  Name

// 你的代码写在这里

#endif
```
