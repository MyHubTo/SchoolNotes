[TOC]
## a.0 库
### a.0.最小cpp系统构成
最小cpp系统构成,只需要一个`CMakeLists.txt`文件和一个`main.cpp`;
```cpp
//CMakeLists.txt
cmake_minimum_required(VERSION 3.0)
project(addlib)
add_executable(test main.cpp)

//所以最小cpp系统只需要三句cmake,如果需要添加自定义的头文件,和库文件,则需要将其包含在add_executable();此部分见##1.

```

### a.1. 不使用用自定义库文件
在Linux中需要使用CMake进行系统文件的构建,如果不生成自定库文件时,**需要将所有源文件都添加到cmake的add_executable()中**,否则编译出错,只能执行`main.cpp`,调用其他自定义的`.h`和`.cpp`中的函数,都会出现编译错误;例如,现有一下源文件:
```cpp

//main.cpp 主程序
#include<iostream>
#include"MyHead.h"
using namespace std;
int main()
{
    myprint("head test");
    return 0;
}
//Myhead.hpp
#ifndef MYHEAD_H
#define MYHEAD_H
#include<string>
#include<iostream>
void myprint(std::string str);
#endif
//Myhead.cpp
#include"MyHead.h"
void myprint(std::string str)
{
    std::cout<<"this my head test"<<std::endl;
    std::cout<<"content is :"<<str<<std::endl;
}
```
此时需要在将新添加的`Myhead.hpp`与`MyHead.cpp`,需要在`CMakeList.txt`文件中`add_executable()`包含进去,告诉编译器,有两个个可执行文件,分别为`main.cpp`,`MyHead.cpp`;否则,编译无法知道`Myhead.hpp`中的`void myprint(std::string str);`是如何执行的,从而导致编译出错;
**所以此时的`CMakeList.txt`如下:**
```cpp
cmake_minimum_required(VERSION 3.0)
project(addlib)
add_executable(test main.cpp MyHead.cpp) ## 将MyHead.cpp也添加为可执行文件
                                         ## main.cpp 中的myprint()是从MyHead.cpp中解析;
```

### a.2.使用库文件
通常我们使用的第三方库都是非开源的,我们只要获得第三方库的**库文件**和**头文件**,就可以使用;而库文件,就是将`.cpp`文件转换成二进制文件,所以此时,我们是无法知道头文件中的某个函数是如何定义,即这个函数的实现方法,**即所有库都是一些函数打包的集合**;为了使用这个库,我们需要知道这个库里面有什么东西,所以此时需要一本`说明`,而这个说明就是`头文件`.所以为了使用第三方库,我们至少需要两个文件**库文件**和**头文件**,本节目的就是实现**生成一个库文件和使用一个库文件**;
在Linux中库文件分为**静态库**和**共享库**;此处我们只讨论**linux下的静态库与共享库**;

静态库是以.a作为后缀名,共享库是.so为后缀的,**所有库都是一些函数打包的集合,差别在于静态库每次调用都会生成一个副本,而共享库则只生成一个副本.**

#### a.2.1 生成静态库
我们可以将自定义的源程序生成**库文件**,此时,我们就可以不用将这个源程序添加到`CMakeLists.txt`中的`add_executable()`,为了使用这个库文件(即`MyHead.cpp`生成的二进制代码),我们需要在`CMakeList.txt`中新添加一句命令用来将这个库文件和我们的`main.cpp`链接起来;
我们只需要改变`CMakeLists.txt`为:
```cpp
cmake_minimum_required(VERSION 3.0)
project(addlib)
add_executable(test main.cpp)

add_library(mylib MyHead.cpp) ## 将MyHead.cpp打包生成静态库,即生成.a文件
target_link_libraries(test mylib) ## 将可执行程序链接到该库上,此时main的myprint()函数才能执行
                                  ## 此时该函数是从生成的.a文件中解析myprint() 
```
#### a.2.2 生成共享库
生成共享库的方法和静态库的方法类似,只需要在`add_library() `添加关键字`SHARED`:
```cpp
cmake_minimum_required(VERSION 3.0)
project(addlib)
add_executable(test main.cpp)

add_library(mylib SHARED MyHead.cpp) ## 将MyHead.cpp打包生成共享库,即.so
target_link_libraries(test mylib) ##将可执行程序链接到该库上,此时main的myprint()函数才能执行
```

### a.3.使用第三库
由前面知道,为了使用第三库,我们需要获取其库文件的和头文件,此处,我们使用自己生成的库文件和头文件;
为了使用第三方库,我们需要指定第三库库文件与头文件对应的位置,最后将源文件与库文件进行链接

#### a.3.1 使用第三库-共享链接库的使用
```cpp
//CMakeLists.txt
cmake_minimum_required(VERSION 3.0)
project(testlib)

#设置第三库的头文件路径与库文件路径
set(INCLUDE_DIRECTORIES ${PROJECT_SOURCE_DIR}/include)
set(LIBRARY_PATH_MY ${PROJECT_SOURCE_DIR}/lib)

message("incude dir:" ${INCLUDE_DIRECTORIES})
message("lib dir:" ${LIBRARY_PATH_MY})

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#添加库

#对于find_package找不到的外部依赖库，可以用add_library添加
# SHARED表示添加的是动态库==>(共享库)
# STATIC表示添加的是静态库
# IMPORTED表示是引入已经存在的动态库
add_library(mylib SHARED IMPORTED)

#指定所添加依赖库的导入路径
set_target_properties(mylib PROPERTIES IMPORTED_LOCATION ${LIBRARY_PATH_MY}/libmylib.so)

# 添加头文件路径到编译器的头文件搜索路径下，多个路径以空格分隔
include_directories( ${INCLUDE_DIRECTORIES} )
# 添加库文件路径到编译器的库文件搜索路径下，多个路径以空格分隔
link_directories(${LIBRARY_PATH_MY})
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

add_executable(${PROJECT_NAME} main.cpp)
target_link_libraries(${PROJECT_NAME} )

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
##链接库
target_link_libraries(${PROJECT_NAME} mylib)
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//main.cpp
#include<iostream>
#include<MyHead.h>//#include"MyHead.h"两者都可以
using namespace std;
int main()
{
    myprint("test my link library");
    return 0;
}
```

#### a.3.2 使用第三库-静态库的使用

静态库的添加与动态库相同,只需要将下面两条语句进行修改:
```cpp
add_library(mylib SHARED IMPORTED)==>add_library(mylib STATIC IMPORTED) ##修改关键字:SHARED==>STATIC
set_target_properties(mylib PROPERTIES IMPORTED_LOCATION ${LIBRARY_PATH_MY}/libmylib.so)==>
==> set_target_properties(mylib PROPERTIES IMPORTED_LOCATION ${LIBRARY_PATH_MY}/libmylib.a) ## 指向静态库

```

```cpp
cmake_minimum_required(VERSION 3.0)
project(testlib)

#设置第三库的头文件路径与库文件路径
set(INCLUDE_DIRECTORIES ${PROJECT_SOURCE_DIR}/include)
set(LIBRARY_PATH_MY ${PROJECT_SOURCE_DIR}/lib)

message("incude dir:" ${INCLUDE_DIRECTORIES})
message("lib dir:" ${LIBRARY_PATH_MY})

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#添加库

#对于find_package找不到的外部依赖库，可以用add_library添加
# SHARED表示添加的是动态库==>(共享库)
# STATIC表示添加的是静态库
# IMPORTED表示是引入已经存在的静态库
add_library(mylib STATIC IMPORTED)

#指定所添加依赖库的导入路径
set_target_properties(mylib PROPERTIES IMPORTED_LOCATION ${LIBRARY_PATH_MY}/libmylib.a)

# 添加头文件路径到编译器的头文件搜索路径下，多个路径以空格分隔
include_directories( ${INCLUDE_DIRECTORIES} )
# 添加库文件路径到编译器的库文件搜索路径下，多个路径以空格分隔
link_directories(${LIBRARY_PATH_MY})
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

add_executable(${PROJECT_NAME} main.cpp)
target_link_libraries(${PROJECT_NAME} )


#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
##链接库
target_link_libraries(${PROJECT_NAME} mylib)
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
```
## 1.1.c++域操作符:
```cpp
#include<iostream>
using namespace std;
int value=0;
void printvalue()
{
    cout<<value<<endl;
}
int main()
{
    int value=10;
    cout<<value<<endl;
    
    /*在c++中可以通过域操作符"::",来直接操作全局变量;但在c中,不支持这个操作,因此会报错*/
    ::value=100;//修改全局变量的值;

    printvalue();
    return 0;
}
```
## 1.2.i++与++i的区别
```cpp
#include<iostream>
using namespace std;
int main()
{
   int i=8;
   cout<<++i<<endl;//i先自增,再打印i的值;->9
   cout<<--i<<endl;//i先自减,再打印i的值;->8
   cout<<i++<<endl;//先打印i的值,再自增;->8
   cout<<i--<<endl;
   cout<<-i++<<endl;//这里"-"表示负号运算,因此先打印-i的值,再i自增1;->-8
   cout<<-i--<<endl;
    return 0;
}
```

## 1.3.++i与i++那个效率高:
 1. 对于内建数据类型的情况下,效率没有区别,因为两者产生汇编代码基本是一致的;
    ```cpp
    i++;
    //mov eax, DWORD PTR _i$[ebp]
    //add eax,1
    //mov DWORD PTR _i$[ebp],eax
    ++i;
    //mov ecx, DWORD PTR _i$[ebp]
    //add ecx,1
    //mov DWORD PTR _i$[ebp],ecx
    ```
 2. 自定义数据情况(类),++i的效率较高;
    对于自定义数据类型,因为前缀式(++i)可以返回对象的引用,而后缀式(i++)必须返回对象的值,所以导致在大对象的时候,产生较大的复制的开销,引起效率降低;
## 1.4.有符号变量与无符号变量的值转换
```cpp
#include<iostream>
#include <limits.h>
using namespace std;
int main()
{
    
   unsigned int i=0; //注意这里i是一个无符号值;
                        //最小值是0;
   cout<<"unsigned int max:"<<UINT_MAX<<endl;//MAX:4294967295
   
   cout<<i<<endl;//->0

   i=-1;//比0小,超出unsigned int范围,返回一个较大值->UINT_MAX-|-1+1|=UINT_MAX,相当于,UINT_MAX的倒数第一个值;->4294967295
   cout<<i<<endl;
   i=-3;//同理,UINT_MAX-|-3+1|=UINT_MAX-2=4294967293;
   cout<<i<<endl;

  //------------------------------------------------------------------------------------------------------------
   char c;
   c=100;//给char 类型赋值一个int类型,相当于将ASCII码为100对应的字符赋值给c;
   cout<<c<<endl;//->d的ASCII=100
   printf("%d\n",c);//->100,其中%d相当于强制转换.等价与->cout<<(int)c<<endl;
   
}
```
## 1.5.不使用任何中间变量,交换a与b的值
```cpp
#include<iostream>

using namespace std;
int swap1(int &x,int &y)
{//采取中间变量法
    int tmp=x;
    x=y;
    y=tmp;
}
int swap2(int &x,int &y)
{//采用加减法,x+y,x-y可能导致,数据溢出
    x=x+y;
    y=x-y;
    x=x-y;
}
int swap3(int &x,int &y)
{//采用异或算法;推荐使用
    //异或:两元素相同为0,不同为1;
    x^=y;
    y^=x;
    x^=y;
}
int main()
{
    int x=2,y=3;
    swap1(x,y);
    cout<<x<<"\t"<<y<<endl;//->3 2
    
    swap2(x,y);
    cout<<x<<"\t"<<y<<endl;//->2 3;前面已经交换了一次

    swap3(x,y);
    cout<<x<<"\t"<<y<<endl;//->3 2
                            //x=2==>010,y=3==>011
                            //x^y=001==>x;
                            //y^x=010==>y;y=2;
                            //x^y=011==>x;x=3;

}
```
## 1.6.C与C++有什么不同

C是一个结构化语言,它的重点在于算法和数据结构,对于语言本身而言,C是C++的子集,C++是对C的扩充.与c语言相比:

C++具有重载、继承和多态三种特性;C++相比 C,增加多许多类型安全的功能,比如强制类型转换;C++支持范式编程,比如模板类、函数模板等

## 1.7.如何理解C++是面向对象化的,而C是面向过程化的

C是面向过程化的,但是C++不是完全面向对象化的.在C++中也可以写出C一样的过程化的程序,所以只能说C++拥有面向对象的特性;

## 1.8.C++中main函数执行完后还会执行其他语句吗
1. 如果定义了类的化,会调用析构函数,进行资源释放;
2. 执行atexit()注册的函数.表示函数正常结束时,要被调用的函数;
    * atexit()函数:函数的参数是一个函数指针,函数指针指向一个**没有参数也没有返回值**的函数;
    * 一个程序中最多可以用atexit()函数注册32个处理函数,且这些**处理函数的调用顺序与其注册顺序<font color=red>相反</font>;**
```cpp
#include<iostream>
using namespace std;
//需要注册的函数没有返回值,也没有参数
void exit1()
{
    std::cout<<"exit1..."<<endl;
}
void exit2()
{
    std::cout<<"exit2..."<<endl;
}
int main()
{
   std::atexit(exit1);//先注册的后执行
   std::atexit(exit2);

   std::cout<<"主函数执行完毕"<<endl;
}
```
## 2.1 宏定义,编译与链接
* 编译:编译的时候**检查语言错误**，包括关键字对应的语义逻辑，括号匹配，变量和函数存在定义或声明等
* 链接:链接的时候，就要真正把需要调用的各种变量和函数的二进制代码匹配起来，比如你使用了某个变量，你使用之前声明为外部定义，而实际上你没有给出过实际定义，这是就会报错了。这是所有可执行代码检测的过程。之前编译是每个文件单独变量，生成obj文件。 
* 不带参数宏定义: **#define 宏名 字符串**:#define PI 3.14 ==>编译时,将所有PI进行替换=3.14,<font color=red>因为替换是在编译之前进行,所以不会对宏名(PI)替换的对象(3.14)进行语法检查,此时的3.14不应该被看作为实数型,而应被看作为一个普通的**字符串常量**</font>
* 带参数宏定义 : **define 宏名(参数表) 字符串**
```cpp
  #define S(a,b) a*b //宏定义中,虽没有定义返回值,但是,是可以通过宏返回运算结果的
  ...
  double result;
  result=S(3,2)//预编译结束后,S(3*2)被3*2代替;
  //此时,3为a的实际参数,2为b的实际参数,则宏名S(3,2)经过预处理后,用3*2替换后再进行编译.即S(a*b)等同行于a*b,而S(3,2)等同于3*2;
```

采用宏定义编译的时候,编译器会"机械"的将所定义的字符进行替换,这种替换<font color=red>可能产生错误</font>;
## 2.2 用#define 实现宏并求最大值和最小值
```cpp
#include <iostream>
using namespace std;
#define MAX(x, y) (((x) > (y)) ? (x) : (y)) //可以将结果直接返回
#define MIN(x, y) (((x) < (y)) ? (x) : (y))
int main()
{
    int a = 2, b = 3, result;
    result = MAX(a, b);
    std::cout << result << endl;

    result = MIN(a, b);
    std::cout << result << endl;
}
```
在宏的定义过程中,由于直接替换可能导致,意外的结果,所以需要用括号,将参数括起来.提高优先级;
## 2.3 宏定义易错点
```cpp
#include <iostream>
using namespace std;
#define SQR(x) (x * x)
int main()
{
    int a, b = 3;
    a = SQR(b + 2);//->输出的是11,而不是25;
    std::cout << a << endl;
}
```
这是由于,宏定义展开是在预处理时期,也就是在编译之前,**此时b并没有被赋值**,这是b只是一个符号.因此展开为->a=(b+2*b+2);所以,进行计算后,得出11;
改正:
可以将#define SQR(x) (x * x)==>#define SQR(x) ((x) * (x))

## 2.4 宏参数的连接

首先来介绍一下这两种功能：
`#`的用法是负责将其后面的东西转化为字符串，比如：
```cpp
#define TO_STRING(str) #str
int main(){
    cout << TO_STRING(this is a string) << endl;
    return 0;
}
```
`##`是连接符，将前后两个东西连接成一个词。比如：
```cpp
#define IntVar(i) int_##i
 
int main(){
    int int_1 = 1, int_2 = 2;
    cout << IntVar(1) << ", " << IntVar(2) << endl;
    return 0;
}
```

```cpp
#include <iostream>
using namespace std;
/*使用#把宏参数变成一个字符串,用##把两个宏参数贴合在一起*/
#define STR(s) #s
#define CONS(a,b) (int)(a##e##b)
int main()
{
    cout<<STR(vck)<<endl;
    cout<<CONS(2,3)<<endl;
}
```

## 2.5 用宏定义得到一个数组所含的元素个数
```cpp
#include <iostream>
using namespace std;
#define ARR_SIZE(a)  (sizeof((a))/sizeof((a[0])))//在编译时,只会将ARR_SIZE(a)替换,此时数组a并不存在,所以需要在使用时,指定数组;
int main()
{
    int arry[100];
    int size=ARR_SIZE(arry);
    cout<<size<<endl;
}
```

## 2.6 找错-const
```cpp
#include <iostream>
using namespace std;

int main()
{
   const int x=1;
   int b=10;
   int c=20;

    /*常量指针:，指针指向的内容是不可改变的，指针看起来好像指向了一个常量。*/
    /*指针常量:在指针常量中，指针自身的值是一个常量，不可改变，始终指向同一个地址。在定义的同时必须初始化。*/
   const int * a1=&b; //常指针,指向常数
   int *const a2=&b; //指针常量,不能改变指针
   const int *const a3=&b;  //指向常量的常指针;

   x=2; //x是const类型,所以不能直接修改

   a1=&c; //正确

   *a1=1;//错误,a1指向是一个常量,不可以被修改

   a2=&c;//错误,指针常量只能在定义时初始化,不可以被赋值;
   *a2=1;//正确
   a3=&c;//错误,指针常量只能在定义时初始化,不可以被赋值;
   *a3=1;//错误;a3指向是一个常量,不可以被修改,同时a3也不可以被修改;
}
```
## 2.7 #define与const的区别
1. #define 只是用来作文本替换;
   ```cpp
   #define PI 3.1415926
   ```
   当程序进行编译的时候,编译器会首先将"#define PI 3.1415926"以后所有的代码中"PI"用3.141592进行替换,然后进行编译.<font color=blue>它的生命期止于编译期,它存在程序的代码段</font>,实际程序中他只是一个常数,一个命令中的参数,并没有实际存在;
2. const 
   const 存在与程序的数据段,并在堆栈上分配空间.const 常量是一个run-time类型的,它在程序中确确实实存在,并可以被调用/传递.编译器可以对const常量**进行安全检查**;
## 2.8 C++ const有什么作用
1. const用于定义常量:const用于定义常量,编译器可以对其进行数据静态类型安全检查;
2. const修饰函数形式的参数;当输入参数为用户自定义类型和抽象数据类型时,应该将值传递改为const &传递,可以提高效率;
    ```cpp
    void fun(A a);
    void fun(A const & a);
    ```
    第一个函数效率低,函数体产生的A类型的临时对象用于复制参数a,临时对象的构造,复制,析构过程都将会消耗时间.
    第二个函数,用引用传递,不需要产生临时对象,节省了临时对象的构造,复制,析构过程消耗的时间.但是光用引用有可能改变a,所以加const.
3. const 修饰函数的返回值;如给"指针传递"的函数返回值加const,则返回值不能被直接修改,且返回值只能被赋值给加const修饰的同类型指针;
4. const修饰类的成员函数:任何不会修改数据成员的函数都应用const修饰,这样,当不小心修改了数据成员调用了非const成员函数,编译器就会报错.
## 2.8 static 的作用
1. 在模块内(在函数体外),一个被声明的**静态变量**,可以被模块内所有的函数访问,但不能被模块外其他函数访问,它是一个本地的全局变量;作用域从定义位置起结束;
2. 在模块内,一个被声明为静态的函数只可被这一模块内的其他函数调用,这个函数被限制在声明它的模块的本地范围内使用.

## 2.9 static 全局变量与普通的全局变量有什么区别
 * 存储方式:两者是相同的,均是静态存储,存储在静态存储区.
 * 作用域:不同,<font color=red>**非静态全局变量**的作用域是整个源程序,当一个程序有多个源文件组成时,非静态全局变量在各个源文件之间都是有效的.</font>而静态全局变量的则限制了其作用域,即只在定义该变量的源文件内有效,在同一个源程序的其它源文件中不能使用它;
 * tips:static 函数与普通函数的区别,static 函数在内存中只有一份,普通函数在每次调用时,维持一份赋值品;
## 2.10 c++静态成员
类的静态成员,是类的公共成员,不同对象共享这一个成员;
静态成员,**只能通过静态成员函数**进行访问,而静态成员函数不仅可以通过`类对象`进行调用,也可以通过`类::静态成员函数`进行调用;
```cpp
#include <iostream>
using namespace std;
class widget
{
private:
    static int count; 
public:
    widget(/* args */);
    static int  num() //!静态成员,必须通过静态成员函数进行操作;
    {
        return count;
    }
    ~widget();
};

widget::widget(/* args */)
{
    count++;    
}

widget::~widget()
{
    --count;
}
int widget::count=0;//!静态成员是公共成员变量,必须在类外进行初始化;
int main()
{
    widget x,y;
    cout<<"widget count:"<<widget::num()<<endl; //==>2
    widget z;
    cout<<"widget count:"<<widget::num()<<endl; //==>3
    return 0;
}
```
结果分析:
输出的结果是2,3.由于静态成员数据是公共成员数据,所以共享成员数据,在构造函数中 `count++`;也就是说,每构造一个类成员,都会导致`count++`,所以,count相当于记录着类成员的个数;

## 2.11 sizeof 普通变量
```cpp
#include <iostream>
using namespace std;
void fun(int arr_[100])
{
    cout<<sizeof(arr_)<<endl;//==> 8;//因为在传递时候,传递是数组arr的地址,所以占用8个字节(64位);
}
int main()
{
    int arr[100];
    char str[] = "Hello";
    int *p = arr; 

    cout << sizeof(arr) << endl;//==>400;此时计算的是一个数组的总共大小;
    cout << sizeof(str) << endl;//==>6 :5个字符+'/0'
    cout << sizeof(p) << endl;  //?==>8 (64位)
                                /*
                                无论是什么类型的指针变量，在32位系统下，一个指针变量所占用的空间是4个字节，
                                在64位下，一个指针变量所占用的空间是8个字节。
                                64位操作系统下，寻址范围的最大长度为64bit，需要用16个十六进制数。
                                表示16个十六进制数，需要4乘16bit，即8Byte
                                */
    fun(arr);//注意传递是数组的首地址,而不整个数组;
    return 0;
}

```
## 2.12 sizeof 计算类对象大小
```cpp
#include <iostream>
using namespace std;
class A
{
public:
    int i;
};
class B
{
public:
    char ch;
};
class C
{
public:
    int i;      //最大基本数据类型:4字节
    short j;
};
class D
{
public:
    int i;      //最大基本数据类型:4字节
    short j;
    char ch;
};
class E
{
public:
    int i;
    int ii;
    short j;
    char ch;
    char chr;
};
class F
{
public:
    int i;
    int ii;
    int iii;
    short j;
    char ch;
    char chr;
};

int main()
{
    
    cout << "sizeof(int)=" << sizeof(int) << endl;          //==>4
    cout << "sizeof(short)=" << sizeof(short) << endl;      //==>2
    cout << "sizeof(char)=" << sizeof(char) << endl;        //==>1

    cout << "sizeof(A)=" << sizeof(A) << endl;      //==>4
    cout << "sizeof(B)=" << sizeof(B) << endl;      //==>1
    cout << "sizeof(C)=" << sizeof(C) << endl;      //==>8
    cout << "sizeof(D)=" << sizeof(D) << endl;      //==>8
    cout << "sizeof(E)=" << sizeof(E) << endl;      //==>12
    cout << "sizeof(F)=" << sizeof(F) << endl;      //==>16
}
```

易错点:
对于 A B类的大小是比较容易理解的,但是为什么C D E F 输出不是 6 7 12 15?而是 8 8 12 16.这是由于**字节对齐**引起的.
**字节对齐是为了提高读取效率**,假如某硬件平台是从偶数字节进行读取,那么如果一个int类型从偶数字节开始存储,那么一个读周期就可以读取,若该int类型从奇数字节开始存储,那么可能需要2个读周期.
所以为了满足字节对齐:
对于C:基本最宽的基本类型为int,大小为4个字节,需要在补三个字节,凑成4的倍数.
<font color =blue>所以,字节对齐最终使得,该类占用的字节数为,最大基本类型的 **整数倍** </font>

## 2.13 sizeof 含有虚函数的类对象的空间大小
```cpp
#include <iostream>
using namespace std;
class Base
{
private:
    int a;
public:
    Base(int x);
    void print()
    {
        cout << "base" << endl;
    }
};

Base::Base(int x) : a(x)
{
}

class Derived : public Base
{
private:
    int b;

public:
    Derived(int x);
    void print()
    {
        cout << "derived" << endl;
    }
};

Derived::Derived(int x) : Base(x - 1), b(x)
{
}

class A
{
private:
    int a;
public:
    A(int x):a(x){}
    virtual void print()
    {
        cout << "A" << endl;
    }
};

class B : public A
{
private:
    int b;

public:
    B(int x):A(x-1),b(x){}
    virtual void print()
    {
        cout << "B" << endl;
    }
};

int main()
{
    Base obj(1);
    cout << "size of Base obj is:" << sizeof(obj) << endl; //==> 4 对于Base类,它占用的内存大小sizeof(int)=4,print()函数不占内存

    Derived obj2(2);
    cout << "size of Derived obj is:" << sizeof(obj2) << endl; //==>8 比Base 多一个 int ,print()函数不占内存;

    A a(1);
    cout << "size of A obj is:" << sizeof(a) << endl;  //==>16? 
                                                        //!对于含有虚函数的类,不仅需要给数据成员分配内存,还需要包含一个隐含的虚表指针成员,
                                                        //!所以,内存大小应该为:sizeof(int)+指针大小; 应该等于 4+8=12,为什么这里是16?

    B b(2);
    cout << "size of B obj is:" << sizeof(b) << endl;  //==>16 比A多一个int
    return 0;
}

```
所以可见,**普通函数不占用内存,只要有虚函数,就会占用一个指针大小的内存**,原因是是系统多用一个指针维护这个类的虚函数表,并且无论多少含有多少个虚函数,都**只会产生一个指针**.

## 2.14 sizeof 计算虚继承的空间大小
```cpp
#include <iostream>
using namespace std;
class A
{
};
class B
{
};
class C : public A, public B
{
};
class D : virtual public A
{
};
class E : virtual public A, virtual public B
{
};
class F
{
public:
    int a;
    static int b;
};
int F::b = 10;
int main()
{
    cout << "sizeof(A)=" << sizeof(A) << endl;      //!==>1,因为没有成员数据,所以编译器会安插一个char给空类,用来标记它的每一个对象;
    cout << "sizeof(B)=" << sizeof(B) << endl;      //==>1,因为没有成员数据,所以编译器会安插一个char给空类,用来标记它的每一个对象;
    cout << "sizeof(C)=" << sizeof(C) << endl;      //==>1,多继承A B,所以编译器会安插一个char给空类,用来标记它的每一个对象;
    cout << "sizeof(D)=" << sizeof(D) << endl;      //==>8(4),虚继承A,编译器为该类安插一个指向父类的指针;
    cout << "sizeof(E)=" << sizeof(E) << endl;      //?==>8,虚继承A,B,此处不应该为16?两个指针,指向两个父类;
    cout << "sizeof(F)=" << sizeof(F) << endl;      //!==>4,存在一个静态成员,这个静态成员的空间,不存在类的实例中,而像全局变量一样,存储在静态存储区;
}

```
## 2.16 sizeof()与strlen()区别==>strlen 在C中定义,在C++中没有;
* sizeof 是操作符,strlen()是函数;
* sizeof 返回值类型不一样,`sizeof`返回值是`size_t`,`strlen()`返回值是`unsigned int`;
* sizeof 可以使用多个类型作为参数,strlen()只能使用char *作为参数;
```cpp
 #include <iostream>
extern "C"
{
    #include <string.h>
}

using namespace std;
int main()
{
    char *str = "hello";
    cout << sizeof(str) << endl; //==> 8,指针存储空间大小
    cout << strlen(str) << endl; //==>5,字符串长度,不包含'/0'
    return 0;
}
```
## 2.17 sizeof 求联合体的大小
```cpp
#include <iostream>
using namespace std;
union u
{
    double a;
    int b;
};
union u2
{
    char a[13];
    int b;
};
union u3
{
    char a[13];
    char b;
};

int main()
{
    cout << "sizeof(double)=" << sizeof(double) << endl; //==>8
    cout << "sizeof(u)=" << sizeof(u) << endl;           //==>8,union,分配内存的大小取决于,它的成员中占用空间最大的一个,
                                                            //同时还要满足**字节对齐**;

    cout << "sizeof(u2)=" << sizeof(u2) << endl;         //==>16,本应该分配13个字节,但是有int 类型,所以还应该满足,字节对齐;
    cout << "sizeof(u3)=" << sizeof(u3) << endl;         //==>13
    return 0;
}
```

## 2.17 \#pragma pack
`\#pragma pack `的主要作用就是改变编译器的内存对齐方式，这个指令在网络报文的处理中有着重要的作用，
`\#pragma pack(n)`是他最基本的用法，其作用是改变编译器的对齐方式， 不使用这条指令的情况下，编译器
默认采取`#pragma pack(8)`也就是8字节的默认对齐方式，n值可以取`（1， 2， 4， 8， 16）` 中任意一值。
```cpp
#include <iostream>
using namespace std;
/*
#pragma pack 的主要作用就是改变编译器的内存对齐方式，这个指令在网络报文的处理中有着重要的作用，
#pragma pack(n)是他最基本的用法，其作用是改变编译器的对齐方式， 不使用这条指令的情况下，编译器
默认采取#pragma pack(8)也就是8字节的默认对齐方式，n值可以取（1， 2， 4， 8， 16） 中任意一值。
*/
#pragma pack(16)  //设置一个字节对齐;
struct test
{
    char c;
    short s1;
    short s2;
    int i;
};

int main()
{
   test ts;
   cout<<sizeof(ts)<<endl; //==>9
    return 0;
}
```

## 2.18 内联函数
内联函数是C++中的一种特殊函数，它可以像普通函数一样被调用，但是在调用时并不通过函数调用的机制而是通过将函数体直接插入调用处来实现的，这样可以大大减少
由函数调用带来的开销，从而提高程序的运行效率。一般来说`inline`用于定义类的成员函数。
inline的使用比较简单，只需要在声明或者定义函数时在头部加上`inline`关键字即可，格式如下:
```cpp
inline 返回值类型  函数名（函数参数）{}
```
一般来说，inline适用的函数有两种，一种是在类内定义的成员函数，另一种是在类内声明，类外定义的成员函数，对于这两种情况inline的使用有一些不同：

(1)类内定义成员函数
这种情况下，我们**可以不用**在函数头部加`inline关键字`，因为编译器会**自动将类内定义的函数声明为内联函数**，代码如下：
```cpp
class temp{
  public:
     int  amount;

  //构造函数
   temp(int amount){
      this->amount = amount;
   }

  //普通成员函数，在类内定义时前面可以不加inline
  void print_amount(){
    cout << this-> amount;
  }
}
```
 从上面的代码可以看出，在类内定义函数时，可以不加inline关键字，编译器会自动将类内定义的函数（构造函数、析构函数、普通成员函数等）设置为内联，具有内联函数调用的性质。
(2) 类内声明函数，在类外定义函数
根据C++编译器的规则，这种情况下如果想将该函数设置为内联函数，则可以在**类内声明时不加inline关键字**，而在**类外定义函数时加上inline**关键字，代码如下所示：
```cpp
class temp{
  public:
     int  amount;

  //构造函数
   temp(int amount){
      this->amount = amount;
   }

  //普通成员函数，在类内声明时前面可以不加inline
  void print_amount()
}

//在类外定义函数体，必须在前面加上inline关键字
inline void temp:: print_amount(){
  cout << amount << endl;
}
```
#### 内联函数的优点:
1.inline 定义的类的内联函数，函数的代码被放入符号表中，在使用时直接进行替换，（像宏一样展开），**没有了调用的开销**，效率也很高。

2.很明显，类的内联函数也是一个真正的函数，编译器在调用一个内联函数时，会**首先检查它的参数的类型**，保证调用正确。然后进行一系列的相关检查，就像对待任何一个真正的函数一样。这样就消除了它的隐患和局限性。（**宏替换不会检查参数类型，安全隐患较大**）

3.inline函数可以作为一个类的成员函数，与类的普通成员函数作用相同，可以访问一个类的私有成员和保护成员。内联函数可以用于替代一般的宏定义，最重要的应用在于类的存取函数的定义上面。
#### 内联函数的缺点：
1. 内联是以代码膨胀(复制)为代价,仅仅省去了函数调用的开销,从而提高函数的执行效率.如果执行函数体内代码的时间相比函数调用的开销较大时,效率就不如采用调用方式高;
2. 内联函数具有一定的局限性，内联函数的**函数体一般来说不能太大**，如果内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。(换句话说就是，你使用内联函数，只不过是向编译器提出一个申请，编译器可以拒绝你的申请）这样，内联函数就和普通函数执行效率一样了。

## 2.19 内联函数与宏的区别*
1. 内联函数在**编译**时展开,宏在**预编译**时展开;
2. 在编译的时候,内敛函数可以直接被镶嵌到目标代码中,而宏只是一个简单文本替换;
3. 内联函数在编译时,对语法进行检查,宏定义在使用时只是简单的文本替换，并**没有做严格的参数检查**，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。

## 3.1 一般引用
* 进行引用时,新定义的引用变量不开辟存储空间;
* 一般引用<font color=red>必须在声明的同时进行绑定,后面**不能**重新绑定变量</font>,即,引用只能在声明的时候被赋值,以后都不能再把引用名作为其他变量名的别名;
;
```cpp
#include <iostream>
using namespace std;

int main()
{
    int a = 50, b = 100;
    int &c = a;         //!不需要给c重新开辟新的存储空间,a与c占用一个存储单元;
    cout << a << " " << b << endl; //==>50 100
    c = 25;
    cout << a << " " << b << endl; //==>25 100

    int qual=(&a==&c)?1:0;

    cout<<qual<<endl; //==> 1,由此可见,将c声明为a的别名,不需要给c重新开辟新的存储空间,a与c占用一个存储单元;
    return 0;
}
```
## 3.2 指针变量的引用;
指针变量引用<font color=red>必须在声明的同时进行绑定,后面**可以**重新绑定变量</font>;
```cpp
#include <iostream>
using namespace std;

int main()
{
    int a = 1;
    int b = 10;

    int *p = &a;
    int *&pa = p; //指针变量的引用,需要在定义时进行绑定;

    (*pa)++; //pa是p的别名;
    cout << "a=" << a << endl;
    cout << "b=" << b << endl;
    cout << "*p=" << *p << endl;

    pa = &b; //pa绑定到b;
    cout << "a=" << a << endl;
    cout << "b=" << b << endl;
    cout << "*p=" << *p << endl;

    return 0;
}
```

## 3.3 变量引用
```cpp
#include <iostream>
using namespace std;

int main()
{
    int a = 1;
    int b = 2;

    int &c; //!错误,引用类型变量在声明的同时**必须**初始化;
    int &d = a;

    &d = b;//!错误,将d当做b的别名,引用只能在声明的时候被赋值,以后都不能再把引用名作为其他变量名的别名;

    int *p; //! 野指针;容易出错;
    *p = 5;
    cout << *p << endl;
    return 0;
}
```
## 3.4 参数引用
```cpp
#include <iostream>
using namespace std;
const float pi=3.1415926;
float f;
float f1(float r) //返回值,通过该函数返回引用,只能返回一个临时变量,所以会出现编译错误;
{
    f=r*r*pi;
    cout<<f<<endl;
    return f;
}
float & f2(float r) //返回引用
{
    f=r*r*pi;
    return f;
}
int main()
{
    //--------------------------------------------------------
    float f1(float=5);//!声明f1()的默认参数调用,默认值为5; 
    float& f2(float=6);//!声明f2()的默认参数调用,默认值为6;
    //--------------------------------------------------------

    float a=f1();
    float &b=f1(); //错误;将变量b赋为f1()的返回值.因为在f1()函数里,全局变量f的值78.5赋值给一个**临时变量**,
                    //这个临时变量是由编译器**隐式**地建立,然后建立这个临时变量的引用,此时对临时变量进行引用,就会发生编译错误;

    float c=f2();

    float &d=f2(); //此种方式返回的是全局变量的引用,而全局变量的声明周期大于d,所以引用是有效的;
    cout<<f<<endl;
    return 0;
}
```
## 3.5 引用错误*
* const 类型可以引用非const 类型:
  ```cpp
  int a=10;
  const int &b=a;//此时b是const 常量,所以,不能改变b的值,例如:b++;是违法的;
  ```
* 非const 类型,不能引用const:
  ```cpp
    const int a=10;
    int &b=a;//b是一个变量,可以改变其值,但是a是一个常量;
  ```
```cpp
#include <iostream>
using namespace std;
class Test
{
public:
    void func(const int &arg)
    {
        //arg=10;//! 错误:arg是一个常量的引用,所以arg的值在函数内不能被修改;
        cout << "arg=" << arg << endl;
        value = 20;
    }

private:
    int value;
};
int main()
{
    int a = 7;
    const int b = 10;
    //int &c=b; //!错误,const 类型可以引用变量,但是,变量不可以引用const类型;==>const int &c=b;
    const int &d = a;

    a++;
    //d++; //! d是常量引用,不能对d赋值,但是,可以改变a的值,所以const 变量是不能直接改变其值,但是可以间接改变其引用的值;

    Test test;

    test.func(a); //!

    cout << "a=" << a << endl;
    return 0;
}
```

## 3.6 指针和引用的区别:

1. 初始化要求不同:
   * 引用: 引用在创建的同时必须初始化,即引用到一个有效的对象;
   * 指针: 指针在创建的时候,可以不初始化,可以在后面重新赋值;
2. 可修改性不同:
   * 引用:引用一旦初始化为指向一个对象,它就不能被改变为另一个对象的引用;
   * 指针:指针在任何时候都可以改变指向一个对象;
3. 不存在NULL引用:
   * 引用: 引用不能使用指向空值的引用,它必须总是指向某一个对象;
   * 指针: 可以指向NULL;

1.指针有自己的一块空间,而引用只是一个别名;
2.**使用 sizeof 看一个指针的大小是 4(8),而引用则是被引用对象的大小;**
3.指针可以被初始化为 NULL,而引用必须被初始化且必须是一个已有对象 的引用;
4.作为参数传递时,指针需要被解引用才可以对对象进行操作,而直接对引 用的修改都会
改变引用所指向的对象;
5.指针在使用中可以指向其它对象,但是引用只能是一个对象的引用,不能 被改变;
6.指针可以有多级指针(**p),而引用至于一级;
7.指针和引用使用++运算符的意义不一样;
8.如果返回动态内存分配的对象或者内存,必须使用指针,引用可能引起内存泄露。

---

## 3.7 传引用比传指针安全:*

1. 引用:
    由于引用不存在空引用,并一旦初始化为指向一个对象,它就不能被改变为另一个对象的引用,因此比较安全;
2. 指针:
    指针可以随时改变指向别的对象,并且可以不被初始化或为NULL,甚至可以出现野指针,所以不安全;

---
## 3.8 指针数组与数组指针
指针数组：指针数组可以说成是”指针的数组”，首先这个变量是一个数组，其次，”指针”修饰这个数组，意思是说这个数组的所有元素都是指针类型，在32位系统中，指针占四个字节。
数组指针：数组指针可以说成是”数组的指针”，首先这个变量是一个指针，其次，”数组”修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。 
```cpp
int *p1[5]；
int (*p2)[5]；
```
首先，对于语句“int*p1[5]”，因为“[]”的优先级要比“*”要高，所以 p1 先与“[]”结合，构成一个数组的定义，数组名为 p1，而“int*”修饰的是数组的内容，即数组的每个元素。也就是说，该数组包含 5 个指向 int 类型数据的指针，如图 1 所示，因此，它是一个指针数组。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210708170258880.jpg#pic_center)
其次，对于语句“int(*p2)[5]”，“()”的优先级比“[]”高，“*”号和 p2 构成一个指针的定义，指针变量名为 p2，而 int 修饰的是数组的内容，即数组的每个元素。也就是说，p2 是一个指针，它指向一个包含 5 个 int 类型数据的数组，如图 2 所示。很显然，它是一个数组指针，数组在这里并没有名字，是个匿名数组。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210708170258882.jpg#pic_center)
由此可见，对指针数组来说，首先它是一个数组，数组的元素都是指针，也就是说该数组存储的是指针，数组占多少个字节由数组本身决定；而对数组指针来说，首先它是一个指针，它指向一个数组，也就是说它是指向数组的指针，在 32 位系统下永远占 4 字节，至于它指向的数组占多少字节，这个不能够确定，要看具体情况。
> 此段摘录:[数组指针和指针数组的区别](http://c.biancheng.net/view/335.html)

```cpp
#include <iostream>
using namespace std;

int main()
{
    //指针数组:数组保存指针;
    int *p1, *p2, *p3;
    int *a[4] = {p1, p2, p3};

    //arr就是我定义的一个指针数组，它有四个元素，每个元素是一个char *类型的指针，这些指针存放着其对应字符串的首地址。
    char *arr[4] = {"hello", "world", "shannxi", "xian"};
    for (int i = 0; i < 4; i++)
    {
        cout << arr[i] << endl;
    }

    //数组指针:一个指针指向一个数组;
    int b[3] = {10, 20, 30};
    int(*p)[3] = &b; //!一个指针,指向一个含有3个整型的数组;==>必须类型 数量 都对应相等;
    /*下面是错误的*/
    //int (*p2)[5] = b;

    for (int i = 0; i < 3; i++)
    {
        cout<<p<<endl;
        cout<<*p<<endl;
        cout << "数组地址arr:"<<&b[i]<< endl;
        cout << "数组地址*p:"<<(*p+i) << endl;
    }
    return 0;
}
```
指针数组与数组指针:TODO==>有点绕;

```cpp
#include <iostream>
using namespace std;
int main()
{
    //指针数组:数组里面存放的指针;
    char *str[] = {"welcome", "to", "Fortemedia", "Nanjing"};
    char **p = str + 1;

    str[0] = (*p++) + 2;
    str[1] = *(p + 1);
    str[2] = p[1] + 3;
    str[3] = p[0] + (str[2] - str[1]);

    cout << str[0] << endl;
    cout << str[1] << endl;
    cout << str[2] << endl;
    cout << str[3] << endl;
}
```
## 3.9 指针加1
**指针 + 1 并不是指针代表的地址值 + 1.一个类型为T的指针的移动，是以sizeof(T)为移动单位。**
指针变量加1，即向后移动1 个位置表示指针变量指向下一个数据元素的首地址。而不是在原地址基础上加1。至于真实的地址加了多少，要看原来指针指向的数据类型是什么。
```cpp
char a = 'a';
char *p = &a;
cout<<(void*)p<<" "<<(void*)(p+1)<<endl;
//输出：0012FF33  0012FF34
```
p指向的是一个字符，p+1就是移动一个字符大小，一个字符就是一个字节，所以p +1 代表的地址就比 p 代表的地址大1。
```cpp
int i = 1;
int *p = &i;
cout<<(void*)p<<" "<<(void*)(p+1)<<endl;
//输出：0012FF30  0012FF34
```
```cpp
int i = 1;
int *p = &i;
cout<<(void*)p<<" "<<(void*)(p+1)<<endl;
//输出：0012FF30  0012FF34
```
> [参考链接](https://blog.csdn.net/qq_33266987/article/details/80842413#:~:text=%C2%A0%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%8A%A01%EF%BC%8C%E5%8D%B3%E5%90%91%E5%90%8E%E7%A7%BB%E5%8A%A81,%E4%B8%AA%E4%BD%8D%E7%BD%AE%E8%A1%A8%E7%A4%BA%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E6%8C%87%E5%90%91%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E7%9A%84%E9%A6%96%E5%9C%B0%E5%9D%80%E3%80%82%20%E8%80%8C%E4%B8%8D%E6%98%AF%E5%9C%A8%E5%8E%9F%E5%9C%B0%E5%9D%80%E5%9F%BA%E7%A1%80%E4%B8%8A%E5%8A%A01%E3%80%82)

**&数组名+1:** 移动一个数组大小,与&(数组名+1)不同,&(数组名+1)移动到数组下一个元素;

```cpp
#include <iostream>
using namespace std;

int main()
{
    int a[5]={1,2,3,4,5};
    int *ptr=(int *)(&a+1);//&a+1==> &a+sizeof(a),也就是a[5]的地址,显然已经超出数组的界限

    cout<<*(a+1)<<endl;//a+1 ==>&a[0]+1==>a[1];
    cout<<*(ptr-1)<<endl;
    return 0;
}
```
 \*(ptr-1)输出为多少？ &a+1不是首地址+1，系统会认为**加了一个a数组，偏移了整个数组a的大小**（也就是5个int的大小）。所以int*p=(int*)(&a+1);其实**ptr实际是&(a[5])**,也就是a+5.原因为何呢？ &a是数组指针，其类型为int(*)[5];（指向含有5个int的数组）， 而指针加1要根据指针类型加上一定的值，不同类型的指针+1之后增加的大小不同，a是长度为5的int数组指针，所以要加5\*sizeof(int)，所以p实际是a[5],但是p与（&a+1）类型是不一样的，这点非常重要，所以ptr-1只会减去sizeof(int\*),a，&a的地址是一样的，但意思就不一样了，**a是数组首地址，也就是a[0]的地址，&a是对象（数组）首地址，a+1是数组下一元素的地址，即a[1],&a+1是下一个对象的地址，即a[5]**。

a是数组首元素的地址;
* &a是整个数组的首地址。二者值一样，但是意义却不相同。
* 数组名代表整个数组的时候只有两种情况：sizeof(数组名),这里的数组名表示整个数组。&数组名，这里的数组名表示整个数组。（对上例数组a，sizeof(a)的值为20，表示整个数组大小。sizeof(a+0)的值为4，因为类似a+0,a+1等数组名进行了偏移运算，那么它就代表指向某个元素的指针）
————————————————
版权声明：本文为CSDN博主「在下能猫」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_23996069/article/details/89309016

## 3.10 相同内容的数据存储地址关系*
```cpp
#include <iostream>
using namespace std;

int main()
{
    char str[] = "abc";
    char str1[] = "abc";

    const char str2[] = "abc";
    const char str3[] = "abc";

    const char *str4 = "abc";
    const char *str5 = "abc";

    char *str6 = "abc";
    char *str7 = "abc";

    /*
    *数组 str str1 str2 str3 都是在栈中分配,内存中的内容都是"abc"+'\0';
    *但是,他们的位置是不同的;
    */
    cout << (str == str1) << endl;  //==0
    cout << (str2 == str3) << endl; //==0

    /*
    *数组 str4 str5 str6 str7 也是在栈中分配,他们都指向字符串"abc",由于"abc"存放在数据区,
    *所以,str4 str5 str6 str7 其实指向同一块数据区内存;
    */
    cout << (str4 == str5) << endl; //==1 
    cout << (str5 == str6) << endl; //==1
    cout << (str6 == str7) << endl; //==1
}
```
## 3.11 内存越界
```cpp
#include<iostream>
extern "C"
{
#include <string.h>
}
using namespace std;

int main()
{
    char *s;
    s="this is a string";
    // cout<<s<<endl;

    char *s2=new char;
    s2="this a new string";     //!这样会导致内存泄露！！！；
                                //!char *s2=new char;-->s2 指向 堆上开辟一段内存空间；
                                //!s2="this a new string";-->s2指向常量区开辟的一段内存空间，此时就会导致一个字节的内存泄露；
    
    // char s3;
    // strcpy(&s3,s2);          //!将s2的内容复制到s3中，但是s3中只分配了一个内存，所以会导致内存越界；
    // cout<<s3<<endl;

    // char *s4=new char;          
    // strcpy(s4,s2);           //! 内存越界，new char 只分配一个字节，而s2需要 18个字节 +‘\0’
    // cout<<s4<<endl;

    char *s5=new char[18];          
    strcpy(s5,s2);           //! 使用动态数组，数组大小>=sizeof(s2)+1;
    cout<<s5<<endl;

    char s6[18];
    strcpy(s6,s2);           //! 使用字符数组；
    cout<<s6<<endl;
    return 0;
}
```
## 3.12 指针常量与常量指针
常量指针:就是指向常量的值指针,它指向的内容是不可以修改的;目的是为了防止程序过程中对指针误操作出现修改常量的错误;
指针常量:就是指针是常量,它是不可改变地址的指针,但是,可以对指针指向的内容进行修改;

## 3.13 this指针
下列关于this指针描述正确的是(A,B)
A. **类的非静态成员函数才有this指针;**
B.类的友元函数,是非成员函数,所以不具有this指针;

## 3.14 函数指针与指针函数 *

指针函数:首先它是一个函数,返回类型是一个指针;
函数指针:首先它是一个指针,指向一个函数;

> Tips: 像这样连着的两个词,前面的一个通常是修饰部分,中心部分在后面;

1. **指针函数**
指针函数，简单的来说，**就是一个返回指针的函数，其本质是一个函数**，而该函数的返回值是一个指针。
声明格式为：
`类型标识符 * 函数名(参数表)`
```cpp
int fun(int x,int y);
```
这种函数应该都很熟悉，其实就是一个函数，然后返回值是一个 int 类型，是一个数值。
接着看下面这个函数声明：
```cpp
int *fun(int x,int y);
```
这和上面那个函数唯一的区别就是在函数名前面多了一个*号，而这个函数就是一个指针函数。其返回值是一个 int 类型的指针，是一个**地址**,<font color=blue>一般返回一个地址是危险的,若返回一个局部变量的地址,该局部变量在其生命周期结束后,就会被销毁,此时该地址的内容是不确定</font>

2. **函数指针**

与指针函数不同，函数指针 的本质是一个指针，该指针的地址指向了一个函数，所以它是**指向函数的指针**。所以调用时,需要指针函数的入口地址给指针;
我们知道，函数的定义是存在于代码段，因此，每个函数在代码段中，也有着自己的入口地址，函数指针就是指向代码段中函数入口地址的指针。
```cpp
#include<iostream>
using namespace std;
/*
 * 求最大值
 * 返回值是int类型，返回两个整数中较大的一个
 */
int max(int a, int b) {
	return a > b ? a : b;
}
 
/*
 * 求最小值
 * 返回值是int类型，返回两个整数中较小的一个
 */
int min(int a, int b) {
	return a < b ? a : b;
}
 
int (*f)(int, int); // 声明函数指针，指向返回值类型为int，有两个参数类型都是int的函数
                    //函数指针,只需要声明,不需要实现;
int main(int argc, char* argv[])
{
	
	f = max; // 函数指针f指向求最大值的函数max
    int c = (*f)(1, 2);
 
	printf("The max value is %d \n", c);
 
	f = min; // 函数指针f指向求最小值的函数min
    c = (*f)(1, 2);
 
	printf("The min value is %d \n", c);
 
	printf("------------------------------ End\n");

	return 0;
}
```

3. **多个函数指针使用**
```cpp
#include<iostream>
using namespace std;
int add1(int x,int y)
{
    return x+y;
}
int add2(int x,int y)
{
    return x+y;
}

int main(int argc, char* argv[])
{
    int (*p[2])(int,int); //!此处定义了一个指针数组,数组存放两个指针,指向不同的函数;
    p[1]=add1;
    p[2]=add2;

    cout<<"p[1](1,2)="<<p[1](1,2)<<endl;
    cout<<"p[2](3,4)="<<p[2](3,4)<<endl;
	return 0;
}
```

## 3.15 typedef 用于函数指针
```cpp
#include<iostream>
using namespace std;
int add1(int x,int y)
{
    return x+y;
}

typedef int (*pFun)(int, int);//! typedef 用于函数指针
                                //! 这里的pFun是一个使用typedef 定义的数据类型,表示一个函数指针
                                //!其参数有两个,都是int型,返回值也是int型;

int (*pFun2)(int,int);// 与上式作对比
int main(int argc, char* argv[])
{
    //------------------------------------------------
    pFun fun=add1;  //! 用 pFun类型定义一个fun,然后调用函数
    cout<<fun(2,3)<<endl;

    //------------------------------------------------

    pFun2=add1;
    cout<<(*pFun2)(3,4)<<endl;
	return 0;
}
```

## 3.16 野指针 与 内存泄露
野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针.**其原因主要是:指针变量没有被初始化,或指针p被free或者delete之后,没有置为NULL**;

内存泄漏(memory leak)是指**由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况**。内存泄漏并非指内存在物理上的消失,而是应用程序分配某段内存后,由于设计错误,失去了对该段内存的控制,因而造成了内存的浪费。

内存泄漏的分类:
1. 堆内存泄漏 (Heap leak)。对内存指的是程序运行中根据需要分配通过 malloc,realloc new 等从堆中分配的一块内存,再是完成后必须通过调用对应的 free 或者 delete 删掉。如果程序的设计的错误导致这部分内存没有被释放,那么此后这块内存将不会被使用,就会产生 HeapLeak.
   
2. 系统资源泄露(Resource Leak)。主要指程序使用系统分配的资源比如Bitmap,handle ,SOCKET 等没有使用相应的函数释放掉,导致系统资源的浪费,严重可导致系统效能降低,系统运行不稳定。
   
3. **没有将基类的析构函数定义为虚函数**。当基类指针指向子类对象时,如果基类的析构函数不是 virtual,那么子类的析构函数将不会被调用,子类的资源没有正确是释放,因此造成内存泄露。

## 3.17 有了malloc/free 为什么还需要new/delete
new/delete和malloc/free的区别

1. malloc和free是库函数，而new和delete是C++操作符；
2. new自己计算需要的空间大小，比如’int * a = new，malloc**需要指定大小**，例如’int * a = malloc(sizeof(int))’；
3. opeartor new /operator delete可以重载，而malloc不行
4. malloc能够直观地重新分配内存
    使用`malloc`分配的内存后，如果在使用过程中发现内存不足，可以使用`realloc`函数进行内存重新分配实现内存的扩充。`realloc`先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。

运算符是语言自身的特性，它有固定的语义，而且编译器也知道意味着什么。就像 +-*/ 一样，由编译器解释语义，生成相应的代码。
<font color=red>库函数是依赖于库的，没有库就没有它，也就是一定程度上独立于语言的。</font>理论上，编译器不知道也不关心函数的作用，编译器只保证编译函数，以及调用该函数时参数和返回值符合语法，并生成相应 call 函数的代码。但实际中一些高级点的编译器，都会对标准库自带的一些函数进行特别处理。

malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。对于非内部数据类型的对象而言，光用malloc/free无法满足动态对象的要求。

对象在创建的同时要自动执行构造函数，对象消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能把执行构造函数和析构函数的任务强加于malloc/free。

对于自定义对象，对象的消亡之前要自动执行析构函数，由于malloc/free是**库函数**而不是**运算符**，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。

## 3.17 内存越界
```cpp
#include <iostream>
using namespace std;
extern "C"
{
#include <string.h>
}

int main(int argc, char *argv[])
{
    char *strp;
    char *str = "test";

    /*内存越界*/
    //    strp=new char[strlen(str)];
    //    strcpy(strp,str);//!内存越界;由于str的长度还有一个'/0';

    strp = new char[strlen(str) + 1]; //新建内存容量,应该+1
    strcpy(strp, str);

    cout << str << endl;
    return 0;
}
```

## 3.18 动态内存传递
```cpp
#include <iostream>
extern "C"
{

#include <string.h>
}
using namespace std;
void getMemory(char *p, int num)
{
    p = new char[sizeof(char) * num];
    cout << sizeof(p) << endl;
}
int main(int argc, char *argv[])
{
    char *strp = nullptr;
    int num = 10;

    //-------------------------------
    getMemory(strp, num);
    //cout<<strlen(strp)<<endl;;//!出错,因为调用getMemory函数体内的p实际上是main函数中strp的备份,变量在getMemory()
    //!函数栈中的一个备份,因为编辑器总是为函数的每一个参数制作临时变量,因此在getMemory()申请
    //!堆内存,但是返回main函数时,strp还是NULL,并不指向那块内存,所以调用此句会出现内存错误;

    return 0;
}
```
对于内存泄露可以通过一下三种方法进行传递动态内存:
1. 采用指向指针的指针,可以将str的地址传给函数GetMemory();
2. 传递指针的引用;
3. 使用返回值来传递动态内存;

```cpp
#include <iostream>
extern "C"
{

#include <string.h>
}
using namespace std;

char *getMemory1(int num)
{
    char *p = new char[sizeof(char) * num];
    return p;
}
void getMemory2(char *&p, int num) //! 传递指针的引用;
{
    p = new char[sizeof(char) * num];
}

void getMemory3(char **p, int num)
{
    *p = new char[sizeof(char) * num];
}
int main(int argc, char *argv[])
{

    char *strp1 = getMemory1(20);
    char *strp2 = nullptr, *strp3 = nullptr;
    getMemory2(strp2, 20);
    getMemory3(&strp3, 20);

    strcpy(strp1, "getMemory 1");
    strcpy(strp2, "getMemory 2");
    strcpy(strp3, "getMemory 3");

    cout << "strp1=" << strp1 << endl;
    cout << "strp2=" << strp2 << endl;
    cout << "strp3=" << strp3 << endl;
    return 0;
}
```

## 3.19 内存泄露 VS 内存溢出
1. **内存泄漏（Memory Leak）**：是指程序中已动态分配的**堆内存由于某种原因程序未释放或无法释放**，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。
   
2. **内存溢出(out of memory)** : 程序在申请内存时，没有足够的内存空间供其使用。一般发生内存溢出时，程序讲无法进行，强制终止。
## 3.20 内存泄露解决方法

通常来说，一个线程的栈内存是有限的，通常来说是 8M 左右（取决于运行的环境）。栈上的内存通常是由编译器来自动管理的。

1. 既然只有堆上会发生内存泄露，那第一原则肯定是避免在堆上面进行内存分配，尽可能的使用栈上的内存，由编译器进行分配和回收，这样当然就不会有内存泄露了。
2. 采用智能指针
   1. `shared_ptr`共享的智能指针：
    `shared_ptr`使用引用计数，每一个`shared_ptr`的拷贝都指向相同的内存。在最后一个`shared_ptr`析构的时候，内存才会被释放。
   2. `unique_ptr`独占的智能指针：
   
   * `Unique_ptr`是一个独占的智能指针，他不允许其他的智能指针共享其内部的指针，不允许通过赋值将一个`unique_ptr`赋值给另外一个 `unique_ptr`。
   * `unique_ptr`不允许复制，但可以通过函数返回给其他的`unique_ptr`，还可以通过`std::move`来转移到其他的`unique_ptr`，这样它本身就不再 拥有原来指针的所有权了
   * 如果希望只有一个智能指针管理资源或管理数组就用`unique_ptr`，如果希望多个智能指针管理同一个资源就用`shared_ptr`。

3. **weak_ptr**弱引用的智能指针：
弱引用的智能指针不会改变引用计数,主要应用于share_ptr 智能指针的循环引用/交叉引用,导致内存资源无法释放,造成内存泄露;

## 4.0 易错
```cpp
#include <iostream>
#include <string>
using namespace std;

int main(int agrv, char *agrc[])
{
    char *str="hello world!";
    cout<<str<<endl; //==>hello world!,输出的不是地址 !!!
    cout<<*str<<endl; //!==>h 解索引输出的是首地址对应的内存内容;

    string str1="test string";
    cout<<str1<<endl;
    string *str2=&str1;
    cout<<*str2<<endl;
    return 0;
}


```
### 4.0.1 string 与char *的区别
1. 定义：
string：string是STL当中的一个容器，对其进行了封装，所以操作起来非常方便。
char*：char *是一个指针，可以指向一个字符串数组，至于这个数组可以在栈上分配，也可以在堆上分配，堆得话就要你手动释放了。
2. 区别：
string的内存管理是由系统处理，除非系统内存池用完，不然不会出现这种内存问题。
char *的内存管理由用户自己处理，很容易出现内存不足的问题。
## 4.1 不使用库函数将数字转换成char
要想将数字转换成字符,将每一个位置上的数字+`'0'`,就可以将此位置上的数字从`int`转换为`char`;
注意:数字只能取正数,不能取负数;
0+'0'='0';
1+'0'='1';
...
9+'0'='9';

所以解法:
1. 首先判断要转换的数字的正负性;负数取绝对值;
2. 提取每一位,然后加`'0'`,转换成`char`;
3. 负数前面加`'-'`;
4. 字符串的最后需要加上`'\0'`

```cpp
#include <iostream>
extern "C"
{

#include <string.h>
}
using namespace std;
void int2char(int n, char *str)
{
    char buff[10] = "";
    int i = 0;
    int len = 0;

    int temp = (n > 0) ? n : -n;

    if (str == nullptr)
    {
        return;
    }

    while (temp)
    {
        buff[i++] = temp % 10 + '0'; //提取每一位数字;
        temp = temp / 10;            //下一位;

        //例如:temp=123
        //1. temp%10=12...3,temp%10=3;temp/10=12;temp=12;
        //2. temp%10=1...2;temp%10=2;temp/10=2;temp=1;
        //1.temp%10=0...1;temp%10=1;temp/10=0;temp=0;退出

        //此时buff中保存的是倒叙:321;
    }

    cout<<i<<endl;
    len = n < 0 ? ++i : i; //如果n是负数,则需要添加一位来保存'-'号;
    str[i] = '\0';            //输出字符串,末尾结束符;'\0'
    cout<<len<<endl;
    while (1)
    {
        i--;
        cout<<i<<endl;
        if (buff[len - i - 1] == '\0')
        {
            break;
        }

        str[i] = buff[len - i - 1]; //倒叙转正序;
    }
    if (i == 0)
    {
        str[i] = '-';
    }
}
int main(int argc, char *argv[])
{
    char p[10];
    int2char(-123, p);
    cout << p << endl;
    
    return 0;
}
```

## 4.2 字符转数字
```cpp
#include <iostream>
extern "C"
{

#include <string.h>
}
using namespace std;
int str2int(const char *str)
{
    int temp=0;
    const char *ptr=str;

    if(*str=='-'||*str=='+') //如果第一字符是正负号,则移动到下一个字符;
    {
        str++;
    }
    while (*str!='0')//==>while (*str!=0) //!'\0'代表ASCII为0的字符,从ASCII表上可以知道,ASCII为0,是一个空字符,不可见.
    {
        if(*str<'0'||*str>'9') //如果字符不是数字,则退出
        {
            break;
        }
        temp=temp*10+(*str-'0');//将字符转换成数字==>-'0';
        str++;

        cout<<temp<<endl;
    }
    return temp;
}
int main(int argc, char *argv[])
{
    int num=str2int("123");
    cout<<num<<endl;
    return 0;
}
```

## 4.3 strcpy()的实现
```cpp
#include <iostream>
using namespace std;
void strCopy(char *strDest, const char *str)
{
    if ((strDest == NULL) || (str == NULL))
    {
        return;
    }

    const char *desstr = strDest; //保存目标首地址;
    while ((*strDest++ = *str++) != '\0')
    {
    }
    return;
}
int main(int agrv, char *agrc[])
{
    char *str1 = "hello world";
    char str2[20];
    strCopy(str2, str1);
    cout << str2 << endl;
    return 0;
}
```
## 4.4 寻找子串*
```cpp
#include <iostream>
extern "C"
{
#include <string.h>
}
using namespace std;

char *comonString(char *str1, char *str2)
{
    int i, j;
    char *longstr, *shorstr;
    if ((str1 == NULL) || (str2 == NULL))
    {
        return NULL;
    }
    if (strlen(str1) <= strlen(str2))
    {
        shorstr = str1;
        longstr = str2;
    }
    else
    {
        shorstr = str2;
        longstr = str1;
    }
    if (strstr(longstr, shorstr) != NULL) //!采用strstr()在一个字符串中,寻找子串;
                                          //! 如果在长的子串中能寻到短的子串,返回短子串;
    {
        return shorstr;
    }

    char *substr = new char[strlen(shorstr) + 1]; //用于保存子串
    for (i = strlen(shorstr) - 1;i > 0; i--)
    {
        cout<<"strlen(shorstr) - 1="<<strlen(shorstr) - 1<<endl;
        for (j = 0; j < strlen(shorstr) - i; j++)
        {
            cout<<"strlen(shorstr) - i="<<strlen(shorstr) - i<<endl;
            memcpy(substr, &shorstr[j], i); //将短字符串的一部分复制到substr,其长度逐渐减小;
            substr[i] = '\0';
            if (strstr(longstr, substr) != NULL) //在longstr中寻找子串;
            {
                return substr;
            }
        }
    }
    return NULL;
}
int main(int agrv, char *agrc[])
{

    char *str1="find test";
    char *str2="test_";
    //cout<<strlen(str2)<<endl; //字符串长度:4;
    char *common=comonString(str1,str2);
    cout<<common<<endl;
    return 0;
}
```

## 4.5 常用c字符串操作
> 此部分内容来自:版权声明：本文为CSDN博主「芮小谭」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/tanrui519521/article/details/81162267
1.  **strlen()**
```cpp
   size_t  strlen( const char*  str)
```
**功能**：计算字符串长度，不包含`’\0’`
**返回值**：返回字符串的`字符数`;
1. strlen() 函数计算的是字符串的实际长度，遇到第一个’\0’结束；
2. 参数指向的字符串必须以 ’ \0 ‘结束
3. 函数返回值一定是size_t ,是无符号的
4. 如果你只定义没有给它赋初值，这个结果是不定的，它会从首地址一直找下去，直到遇到’\0’停止
5. sizeof返回的是变量声明后**所占的内存数,对于字符串会包含'\0'所占用的内存，不是实际长度**，此外sizeof不是函数，仅仅是一个操作符，strlen()是函数;
```cpp
#include <iostream>
extern "C"
{
#include <string.h>
}
using namespace std;
int main(int agrv, char *agrc[])
{
    char str1[] = "test";
    cout << sizeof(str1) << endl; //==>5 因为'\0'占有内存;
    cout << strlen(str1) << endl; //==>4 不包含'\0'长度;
    return 0;
}
```
2. **strcpy()**
```cpp
char* strcpy(char* dest,char* src)
```
**功 能**: 将参数src字符串拷贝至参数dest所指的地址
**返回值**: 返回参数dest的字符串**起始地址** 
* 源字符串必须以’\0’结束
* 会将源字符串的’\0’拷贝到目标空间
* 目标空间必须可变
* 如果参数dest所指的内存空间不够大，可能会造成缓冲溢出的错误情况，在编写程序时需特别留意，或者用`strncpy()`来取代

3. **strncpy()**
```c
char* strncpy(char* dest,const char* src,size_t num)
```

**功能**：拷贝src字符串的前num个字符至dest
**返回值**：dest字符串起始地址
说明：
* 如果src字符串长度小于num，则拷贝完字符串后，在目标后追加0
* strncpy**不会向dest追加’\0’**
* src和dest所指的内存区域不能重叠，且dest必须有足够的空间放置n个字符

4. **strcat()**
```c
char* strcat(char* dest,const char* src)
```

**功能**： 字符串拼接
**返回值**：返回dest字符串起始地址
说明：
- 源字符串必须’\0’结束
- 目标空间必须可修改
- strcat() 会将参数src字符串复制到参数dest所指的字符串尾部
- **dest最后的结束字符’\0’会被覆盖掉，并在连接后的字符串的尾部再增加一个’\0’**
- dest与src所指的内存空间不能重叠，且dest要有足够的空间来容纳要复制的字符串

5. **strncat()**
```c
char* strncat (char* dest,const char* src,size_t num)
```
**功能**：将n个字符追加到字符串结尾
**返回值**：返回dest字符串的起始地址
说明：
* strncat将会从字符串src的开头拷贝n个字符到dest字符串尾部
* dest要有足够的空间来容纳要拷贝的字符串
* 如果n大于字符串src的长度，那么仅将src全部追加到dest的尾部
* strncat会将dest字符串最后的’\0’覆盖掉，字符追加完成后，再追加’\0’ 

6.**strcmp()**
```c
int strcmp (const char* str1,const char* str2)
```
**功能**：字符串比较
**返回值**：若参数s1和s2字符串相同则返回0，s1若大于s2则返回大于0的值，s1若小于s2则返回小于0的值
说明：
* 判断两个字符串大小1）ASII码 2）长度
* 区分大小写比较的，如果希望不区分大小写进行字符串比较，可以使用stricmp函数 
7. **strncmp()**
```c
int strncmp(const char* str1,const char* str2,size_t num)
```
**功能**：指定长度比较

8.**strstr()**
```c
char* strstr(const char* str,const char* substr)
```
**功能**：检索子串在字符串中首次出现的位置
**返回值**：返回字符串str中第一次出现子串````的地址；如果没有检索到子串，则返回NULL 
## 5.位制转换

在32位计算机中,`int`与`float` 均占4个字节,`double`占有8个字节;一般情况下,在c++中,使用`cout`输出是没有问题的,但是采用`printf()`会涉及位制转换导致读取错误;

`printf()`会根据说明符`"%f"`.编译器认为参数应该是`double`类型(在`printf`函数中,`float`会自动转换成为`double`),因此会从栈中读出8个字节.类似地,当`printf()`说明符为`"%d"`时,编译器认为参数应该是`int`类型,因此会从栈中读出4个字节;
```cpp
#include<iostream>
using namespace std;
int main()
{
 
    printf("%f\n",5);//可能存在内存越界的错误:参数5是一个int型,所以在栈中分配了4个字节的内存用于存放参数5,然后在printf从栈中读取8个字节;
    printf("%d\n",5.01);//出错!参数5.01占用8个字节,读取时读取了4个字节,所以内存越界;
    printf("%f\n",5.01);
    
    return 0;
}
```
## 6.1 private 数据类型
private：用来指定私有成员。一个类的私有成员，**不论是成员变量还是成员函数，都只能在该类的成员函数内部才能被访问。**
```cpp
#include <iostream>
using namespace std;
class A
{
private:
    void print()
    {
        cout << "private print" << endl;
    }
public:
    void print2()
    {
        print();//一个类的私有成员，不论是成员变量还是成员函数，都只能在该类的成员函数内部才能被访问。
        cout<< "public print" << endl;
    }
};

int main()
{
    A a;
    a.print2();
    //a.print(); 无法调用
    return 0;
}
```

## 6.2 初始化的坑
```cpp
#include <iostream>
using namespace std;
class A
{
private:
    int i;
    int j;
public:
    A(int x):j(x),i(j){}
    void print()
    {
        cout<<"i="<<i<<"\n"<<"j="<<j<<endl;
    }
};
int main()
{
    A a(10);
    a.print();//==>i=0;j=10;
    
    return 0;
}
```
**此处初始化完成后,i!=10;**(<font color=red>错误认为</font>:先用10对j初始化,然后再用j对i初始化,所以两者的结果都是10 )
<font color=red>初始化成员列表的初始化顺序与变量声明的顺序一致</font>:而不是按照出现在初始化列表中顺序;
这里成员i比成员j先声明,因此成员i先被初始化,而此时j未被初始化,j是一个随机值,故i的值也是**随机值**;(==0?)

## 6.3 析构函数与构造函数是否可以被重载
构造函数:可以重载;
析构函数:不可以,析构函数只能有一个;

## 6.4 构造函数中explict与普通函数的区别
```cpp
#include <iostream>
using namespace std;
class Test1
{
private:
    int num;
public:
   Test1(int n):num(n){}
};
class Test2
{
private:
    int num;
public:
   explicit Test2(int n):num(n){} //explicit(明确的) 显示构造函数
};
int main()
{
    Test1 test1(10);
    Test1 test2=20; //隐式调用其构造函数

    Test2 test3(30);
    //Test2 test4=40; //编译错误,不能通过隐式转换调用其构造函数;
    return 0;
}
```
## 6.5 explicit 的作用
```cpp
#include <iostream>
#include <string>
using namespace std;
class Number
{
public:
    string type;
    Number() : type("void") {}
    explicit Number(short) : type("short") {}
    Number(int) : type("int") {}
};

void show(const Number &n) { cout << n.type << endl; }
int main()
{  
    short s = 42; //'='表示赋值,即隐式转换
    // Number num=s;       //采用隐式调用;
    // show(num);          //!输出==>int
    show(s); //!输出==>int
             //!原因如下:show(s)的s为short类型,其值为42,因此会首先检查参数为short的构造函数是否被隐式转换.
             //!由于short类型的构造函数被声明为explict 所以不可以被隐式转换;
             //!42 会被自动转换成int 类型;
             //!检查int类型是否可以被隐式转换,int类型的构造函数没有explicit 声明,所以可以进行隐式转换,因此输出int

    short ss = 45;
    Number num2(ss);
    show(num2); //输出==>short
    return 0;
}
```
## 6.6 继承类析构方式
```cpp
#include <iostream>
#include <string>
using namespace std;
class A
{
private:
    int a;
public:
    A(int aa);
    ~A();
};
A::A(int aa):a(aa)
{
}
A::~A()
{
    cout<<"destructor A"<<a<<endl;
}
class B:public A
{
private:
    int b;
public:
    B(int aa,int bb);
    ~B();
};

B::B(int aa=0,int bb=0):A(aa),b(bb)
{
}

B::~B()
{
    cout<<"destructor B"<<b<<endl;
}

int main()
{
    B obj(5),obj2(6,7);//==>输出
                                /*  destructor B7
                                    destructor A6
                                    destructor B0
                                    destructor A5
                                */
    return 0;
}
```
**所以析构函数执行不光只执行继承类的析构函数,还要执行基类的析构函数!!**

## 7.类的继承
 1. 类的成员数据类型;
    
    * protected:protectd成员数据或者成员函数，<font color=blue>只能被**本类**或**本类派生类**中的**成员函数**访问；</font>
    * private:private成员数据或者成员函数，<font color=blue>只能被**本类**中的**成员函数**访问；</font>
    * public :public成员数据或者成员函数，<font color=blue>既可以被**本类**的成员函数访问，也可以被**类外的函数**访问</font>
 2. 类继承方式:
    * public 继承:基类的中的***公有成员***(成员:成员函数与成员数据)和***保护成员***,在派生类中的**访问权限不变**,仍然是公有成员和保护成员;私有成员,在继承类中访问权限是不可访问;
    * protected 继承:基类的中的公有成员(成员:成员函数与成员数据)和保护成员,在派生类中的访问权限变为**保护成员**;基类中公有成员和保护成员在**派生类内部**都是可以访问的;私有成员,在继承类中访问权限是不可访问;
    * private 继承: 基类的中的公有成员(成员:成员函数与成员数据)和保护成员,在派生类中的访问权限变为**私有成员**;私有成员,在继承类中访问权限是不可访问;
    * 由此可见,无论何种继承方式,基类的private成员,均是不可以访问;



|基类中的成员|在公有派生中的访问属性|在保护派生中的访问属性|在私有派生中的访问属性|
|---------|----------|----------|----------|
|私有成员|不可访问|不可访问|不可访问|
|保护成员|保护|保护|私有|
|公有成员|公有|保护|私有|

```cpp
#include <iostream>
#include <string>
using namespace std;
class A
{
private:
    int a;
    void printf_private()
    {
        cout << a << b << c << endl;
    }

protected:
    int b;
    void printf_protected()
    {
        cout << a << b << c << endl;
    }

public:
    int c;
    A(int a_, int b_, int c_) : a(a_), b(b_), c(c_){};

    void printf_public()
    {
        cout << a << b << c << endl;
    }
};
class B : public A
{
public:
    B(int a_, int b_, int c_) : A(a_, b_, c_) {}
    void B_print_public()
    {
        printf_protected();
        printf_public();
        //cout<<a<<endl; //public 继承后,基类的私有成员或成员函数均是不能访问的;
        cout << b << endl;
        cout << c << endl;
    }
};
class C : protected A
{
public:
    C(int a_, int b_, int c_) : A(a_, b_, c_) {}
    void C_print_public()
    {
        printf_protected();
        printf_public();

        //cout<<a<<endl;//protected 继承后,基类的私有成员或成员函数均是不能访问的;
        cout << b << endl;
        cout << c << endl;
    }
};
class D : private A
{
public:
    D(int a_, int b_, int c_) : A(a_, b_, c_) {}
    void D_print_public()
    {
        printf_protected();
        printf_public();
        //cout<<a<<endl; //private 继承后,基类的私有成员或成员函数均是不能访问的;
        cout << b << endl;
        cout << c << endl;
    }
};
int main()
{
    B b_public(1, 2, 3);
    C c_protected(1, 2, 3);
    D d_private(1, 2, 3);

    b_public.printf_public();
    b_public.B_print_public();
    cout << b_public.c << endl; //public 继承的public成员数据,可以被访问

    c_protected.C_print_public();
    //c_protected.printf_public();  //保护继承,只能在类的成员函数中访问
    //cout<< c_protected.c<<endl;   //保护继承,基类的public成员,访问属性为protected,只能在类的成员函数内部访问;

    d_private.D_print_public();
    //d_private.printf_public();   //私有继承,只能在类的成员函数中访问;
    //cout<<d_private.c<<endl;     //私有继承,基类的public成员,访问属性为private,只能在类的成员函数内部访问;
    return 0;
}
```
## 7.1 继承中构造函数调用方式
```cpp
#include <iostream>
#include <string>
using namespace std;

void prinln(const std::string &msg)
{
    cout << msg << endl;
}
class Base
{
public:
    Base()
    {
        prinln("Base::Base()");
        virt();
    }
    void f()
    {
        prinln("Base::f()");
        virt();
    }
    virtual void virt()
    {
        prinln("Base::virt()");
    }
};

class Derived : public Base
{
public:
    Derived()
    {
        prinln("Derived::Derived()");
        virt();
    }

    virtual void virt()
    {
        prinln("Derived::virt()");
    }
};

int main()
{
    Derived d;
    Base *pB = &d;
    pB->f();
    return 0;
}
```
1. 构造Derived 对象d.**首先调用Base的构造函数,然后调用Derived的构造函数**.在Base类的构造函数中,有调用了虚函数`virt()`,此时虚拟机制还没有开始作用(因为是在构造函数中),所以执行的是`Base`类的`vitr()`函数.同样,在`Derived`类的构造函数中,执行的是`Derived`类的`virt`函数;

2. 通过Base类的指针pB访问Base类的公有成员函数f(),**f()函数又调用了虚函数virt(),这里出现了多态,由于指针pB是指向Derived类对象的,因此实际执行的Derived类的virt()成员**;
3. <font color=blue>所以,对于继承类说,如果是构造函数, **则首先构造基类的构造函数,然后执行继承类的构造函数;对于析构函数,则是先析构继承类,然后析构基类;**,</font>

## 7.2 虚函数与纯虚函数的区别
1. 类里面如果声明了虚函数,这个函数是实现的,哪怕是空实现,它的作用就是能让这个函数在它的子类中里面可以覆盖,这样编译器就可以使用后期绑定来达到**多态**了.虚函数只是一个接口,是个函数的声明而已,他要留到子类里去实现;
2. 虚函数在子类里面可以不重载,但纯虚函数**必须**要到子类去实现;
3. 所以**虚函数**的目的是为了**实现多态**,**纯虚函数**的作用是为了**预留一个接口**和**多态的实现**;
4. 带纯虚函数的类叫做抽象类,<font color=red>这种基类不能直接定义对象,而只有被继承,并重写了其虚函数后,才能使用,但可以定义其**指针**或**引用** </font>;

### 7.2.1 虚函数
```cpp
#include<iostream>
#include<cmath>
using namespace std;
const double PI=3.1415926;
class Circle
{
protected:
    double r;
public:
    Circle(double rad)
    {
        r=rad;
    }
    double Peri()
    {
        return 2*PI*r;
    }
    virtual double Area()           //基类虚函数
    {
        return PI*r*r;
    }
};
class Cyclinder:public Circle
{
    double h;
public:
    Cyclinder(double rad,double heigth):Circle(rad)
    {
        h=heigth;
    }
    double Area()      //!==>尽管重新定义了Area(),但新定义的Area继承了基类的虚特性,成为虚函数,具有虚函数的特性;  ==> virtual double Area()
    {
        return Peri()*h;
    }
};
class Cone:public Circle
{
    double h;
public:
    Cone(double rad,double heigth):Circle(rad)
    {
        h=heigth;
    }
    double Area()       //!==>尽管重新定义了Area(),但新定义的Area继承了基类的虚特性,成为虚函数,具有虚函数的特性;  ==> virtual double Area()
    {
        return PI*r*sqrt(r*r+h*h);
    }
};
void fun(Circle *pb)
{
    cout<<pb->Area()<<endl;
}
int main()
{   
    Cyclinder cy(3,5);
    Cone cn(3,5);
    cout<<"圆柱体的侧面积是：";
    fun(&cy);
    cout<<"圆锥体的侧面积是：";
    fun(&cn);
    return 0;
}
```
由于在基类Circle中将Area函数定义为虚函数(A行),在其派生类Cylinder和Cone中,**尽管也重新定义了Area(B行和C行),但新定义的Area继承了基类的虚特性,成为虚函数,具有虚函数的特性**.这样,当基类指针指向派生类对象,并且用基类指针调用虚函数(pb->Area())时,执行的是派生类中新定义的同名函数,即分别求Cylinder和Cone的侧面积;

### 7.2.2 纯虚函数
```cpp
#include<iostream>
#include<cmath>
using namespace std;
const double PI=3.1415926;
class Circle
{
protected:
    double r;
public:
    Circle(double rad)
    {
        r=rad;
    }
    double Peri()
    {
        return 2*PI*r;
    }
    virtual double Area()
    {
        return PI*r*r;
    }
    virtual double volume()=0;          //纯虚函数，预留接口，保证多态性
    
};
class Cyclinder:public Circle
{
    double h;
public:
    Cyclinder(double rad,double heigth):Circle(rad)
    {
        h=heigth;
    }
    double Area()
    {
        return Peri()*h;
    }
    virtual double volume()
    {
        return Circle::Area()*h;        //冲突与支配，否则会执行派生类中的Area()
    } 
};
class Cone:public Circle
{
    double h;
public:
    Cone(double rad,double heigth):Circle(rad)
    {
        h=heigth;
    }
    double Area()
    {
        return PI*r*sqrt(r*r+h*h);
    }
    virtual double volume()
    {
        return Circle::Area()*h/3;        //冲突与支配，否则会执行派生类中的Area()
    } 
};
void fun(Circle *pb)
{
    cout<<pb->Area()<< " "<<pb->volume()<<endl;
}
int main()
{   
    //Circle circle(5);         //!抽象类不能定义对象;
    Circle *circle_ptr;        //!但可以定义指针与引用;

    Cyclinder cy(3,5);
    Cone cn(3,5);
    cout<<"圆柱体的侧面积和体积是：";
    fun(&cy);
    cout<<"圆锥体的侧面积和体积是：";
    fun(&cn);
    return 0;
}
```
## 7.3 函数重载与重写的区别：

### 7.3.1 重载
重载是指同一可访问区内被声明的几个具有**不同参数列表**（参数的类型，个数，顺序不同）的**同名函数**，根据参数列表确定调用哪个函数，重载不关心函数返回类型，返回值可以不同。


### 7.3.2 重写（覆写）

重写是指派生类中存在重新定义的函数。**其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致**。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。

重写方法的规则：

1）、参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。

2）、**返回的类型**必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。

重载方法的规则：

1）、必须具有不同的参数列表；

2）、**可以**有不同的返回类型，只要参数列表不同就可以了；

## 8.1 STL 
```cpp
#include <iostream>
#include <vector>
#include <thread>
using namespace std;
int main()
{
    vector<int> array;
    for (int i =1; i < 4; i++)
    {
        array.push_back(i);
    }

   for(vector<int>::size_type i=array.size()-1;i>=0;i--)
   {
       cout<<array[i]<<endl;
       this_thread::sleep_for(chrono::seconds(1));
   }
    return 0;
}
```
此程序是一个死循环!!原因在与`vector<int>::size_type`的类型;
`vector<int>::size_type`<==typedef _SIZT size_type;<==typedef unsigned int size_t;所以size_type 是一个unsigned int 类型,是一个**>=0**的数,所以此循环会导致死循环:
```cpp
#include <iostream>
#include <vector>
#include <thread>
using namespace std;
int main()
{
    vector<int> array;
    for (int i = 1; i < 4; i++)
    {
        array.push_back(i);
    }

    //    for(vector<int>::size_type i=array.size()-1;i>=0;i--)
    //    {
    //        cout<<array[i]<<endl;
    //        this_thread::sleep_for(chrono::seconds(1));
    //    }
    for (vector<int>::size_type j = array.size(); j > 0; j--)
    {
        cout << array[j - 1] << endl;
        this_thread::sleep_for(chrono::seconds(1));
    }

    for (int k = array.size()-1; k >= 0; k--)
    {
        cout << array[k] << endl;
        this_thread::sleep_for(chrono::seconds(1));
    }
    return 0;
}
```
## 8.2 STL 删除某一个元素后,会自动移项
```cpp
/*
*删除程序中所有的2;
*/

#include <iostream>
#include <vector>
#include <thread>
using namespace std;
int main()
{
    vector<int> array;
    array.push_back(1);
    array.push_back(2);
    array.push_back(2);
    array.push_back(3);

    for (vector<int>::iterator itor = array.begin(); itor != array.end(); itor++)
    {
        if (2 == *itor)
        {
            array.erase(itor); //通过此方法只会删除一个2;
                                //! 这是因为每次调用"array.erase(itor);",被删除的元素之后的内容就会自动往前移动,
                                //!导致漏项,应该在删除一项后使itor--,使之从已经前移的下一个元素起继续遍历;
            itor--;      //添加此句,才不会导致漏项!!
        }
    }

    for (auto &index : array)
    {
        cout << index << endl;
    }
}
```
`array.erase(itor);` //通过此方法只会删除一个2;
                    //! 这是因为每次调用"array.erase(itor);",被删除的元素之后的内容就会自动往前移动,
                    //!导致漏项,应该在删除一项后使itor--,使之从已经前移的下一个元素起继续遍历;

## 8.3 list 与vector的区别
vector 与数组类似,它拥有一段连续的内存空间,并且起始地址不变,因此他能非常好的支持随机存取(使用[]操作符访问其中的元素).但是,由于它的内存空间是连续的,所以在进行插入操作和删除操作会造成内存的块拷贝,当内存空间不够时,需要重新申请一块足够大的内存并进行内存的拷贝;

list是由数据结构中的双向链表实现的,因此它的内存空间可以是不连续的,所以插入与删除效率很高;

## 8.4 请你来说一下STL中迭代器的作用，有指针为何还要迭代器
1. 迭代器
Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素,而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展iterator。

2. 迭代器和指针的区别 *
**迭代器不是指针，是类模板，表现的像指针**。他只是模拟了指针的一些功能，重载了指针的一些操作符，`->、*、++、--`等。迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象，本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的`++，--`等操作。迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用`*`取值后的值而不能直接输出其自身。

3. 迭代器产生原因
Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。

## 8.5 程序从开始到运行的完整步骤
预处理，编译，汇编，链接
**预处理**:在预处理的过程中，主要处理源代码中的预处理指令，引入头文件，去除注释，处理所有的条件编译指令，宏的替换，添加行号，保留所有的编译器指令。
**编译**:编译过程所进行的是对预处理后的文件进行语法分析，词法分析，语义分析，符号汇总，然后生成**汇编代码**。
**汇编**:汇编过程将汇编代码转成二进制文件，二进制文件就可以让机器来读取。每一条汇编语句都会产生一句机器语言。
**链接**:
由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数等等。所有这些问题，都需要经链接程序的处理方能得以解决。链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。

## 8.6.静态编译和动态编译的区别与优缺点

静态链接：后缀是.a，主要在编译的时候将库文件里面代码搬迁到可执行的文件中；

动态链接：后缀是.so,主要在执行的时候需要转换到库文件代码执行；

两种链接的优缺点：

（1）静态的链接产生的可执行的文件体积比较的大；而动态链接的可执行文件的体积比较小；
（2）动态的链接的编译的效率比较的高；
（3）静态链接的可执行的文件执行的效率高;
（4）静态链接的可执行的文件的“布局”比较好一点；
## 8.7.内存池和线程池的原理

1. 内存池，即使用内存前，预先分配一个大的内存空间，然后使用内存时，就从中分出一部分内存块，使用并记录即可。
2. 线程池，即程序运行前，预先创建多个线程，然后在接收新任务的时候就会选择线程执行任务。

## 8.8.桌子上一堆红包，切两刀，分为三组
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    //桌子上一堆红包，切两刀，分为三组，如果第一组和第三组的总金额相同，输出总金额（可以为空）
    //先比较左1和右1，如果左1<右1，比较左1+左2和右1，以此类推，直到两刀相遇，如果此时还不等，那就返回0。
    int hb[]={2,3,5,6,2,1,8,9,1,4,6,8};

    int arrsize=sizeof(hb)/sizeof(int);

    int *left=hb,*right=hb+arrsize-1;

    int leftSum=0,rightSum=0;

    leftSum+=(*left),rightSum+=(*right);
    while (left<=right)
    {
        if(leftSum==rightSum)
        {
            cout<<leftSum<<endl;
            break;
        }
        if(leftSum<rightSum)
        {
            left++;
            leftSum+=(*left);
        }
        else{
            right--;
            rightSum+=(*right);
        }
    }
    return 0;
}
```
## 8.9. 为什么基类的析构函数是虚函数？为什么 C++默认的析构函数不是虚函数?
在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类,造成内存泄露.

C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针,占用额外的内存。而对于不会被继承的类来说,其析构函数如果是虚函数,就会浪费内存。因此 C++默认的析构函数不是虚函数,而是只有当需要当作父类时,设置为虚函数。

## 8.10 为什么析构函数可以是纯虚函数？

在某些类里声明纯虚析构函数很方便。纯虚函数将产生抽象类——不能实例化的类（即不能创建此类型的对象）。有些时候，你想使一个类成为抽象类，但刚好又没有任何纯虚函数。怎么办？因为抽象类是准备被用做基类的，基类必须要有一个虚析构函数，纯虚函数会产生抽象类，所以方法很简单：在想要成为抽象类的类里声明一个纯虚析构函数。
```cpp
class Test {
public:
virtual ~Test() = 0; // 声明一个纯虚析构函数
};
```
这个类有一个纯虚函数，所以它是抽象的，而且它有一个虚析构函数，所以不会产生析构函数问题。但这里还有一件事：必须提供纯虚析构函数的定义：
```cpp
    Test::~Test() {} // 纯虚析构函数的定义
```
这个定义是必需的，因为虚析构函数工作的方式是：最底层的派生类的析构函数最先被调用，然后各个基类的析构函数被调用。这就是说，即使是抽象类，编译器也要产生对~awov的调用，所以要保证为它提供函数体。如果不这么做，链接器就会检测出来，最后还是得回去把它添上。

虽然抽象类的析构函数可以是纯虚函数，但要实例化其派生类对象，仍必须提供抽象基类中析构函数的函数体。

抽象类的纯虚函数的实现可以由自身给出，也可以由派生类给出。错了，除了析构函数外，其他函数都不行，必须要在派生类中进行实现。
```cpp
class a 
{ 
public: 
virtual ~a()=0; 
}; 

class b:public a 
{ 
public: 
virtual ~b(){}; 
}; 

int main() 
{ 
b bb; 
return 1; 
} 
```
析构函数是纯虚函数的亦为抽象类。 
上面的例子所以错误，因为b继承a后没有改写a的纯虚函数，因此b也是抽象类，自然不能实例化。 
修改如下则正确：
```cpp 
class a 
{ 
public: 
virtual ~a()=0; 
}; 

class b:public a 
{ 
public: 
virtual ~b(){}; 
}; 

a::~a(){};//改写a的纯虚函数，此时a仍为抽象类 

 

int main() 
{ 
b bb; 
return 1; 
} 
```
注意此时a仍为抽象类不能实例化，a aa则错误。 

## 8.11 软开面试题总结
> 1 、给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变？
```cpp
#define BIT3 (0x1 << 3)//1左移3位
static int a;
void set_bit3(void)
{
  a |= BIT3;        //第三位置1
}

void clear_bit3(void)
{
    a &=(~BIT3);    //第三位复位
}
```
> 2 、1000瓶毒药里面只有1瓶是有毒的，问需要多少只老鼠才能试出那瓶有毒。

首先 老鼠有两种状态 死和活，符合二进制。其次要用死和活来唯一标识1000个酒桶，也就是10位二进制 2的10次方=1024。
从编号最后1位是1的所有的瓶子里面取出1滴混在一起（比如从第一瓶，第三瓶，。。。里分别取出一滴混在一起）并标上记号为1。以此类推，从编号第一位是1的所有的瓶子里面取出1滴混在一起并标上记号为10。现在得到有10个编号的混合液，小白鼠排排站，分别标上10，9，。。。1号，并分别给它们灌上对应号码的混合液。24小时过去了，过来验尸吧： 
从左到右，死了的小白鼠贴上标签1，没死的贴上0，最后得到一个序号，把这个序号换成10进制的数字，就是有毒的那瓶水的编号。 

> 3、有粗细不同的绳子，假设每根绳子烧完的时间都是一个小时，至少需要几根绳子才能计算45分钟？（只允许做点燃操作）
**两根**
将1号两头同时点燃同时把2号一头点燃，当1号烧完时点燃2号的**另一头**，等2号烧完就是45分钟。

> 4 、关键字volatile有什么含义

一个定义为volatile的变量是说这变量可能会被意想不到地改变,这样,编译器就不会去假设这个变量的值了.精确地说就是,优化器在用到这个变量时必须每次都小心地重新读取这个变量的值,而不是使用保存在寄存器里的备份.下面是volatile变量的几个例子：
　　1).并行设备的硬件寄存器（如：状态寄存器）
　　2).一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
　　3).多线程应用中被几个任务共享的变量

## 8.12 c = a+++b
```cpp
int a = 5, b = 7, c;
c = a+++b; 
等同于 c = a++ + b; //a等于5先进行计算，计算完后在自行加1；
因此, 这段代码持行后a = 6, b = 7, c = 12。
```
## 8.13 用struct关键字与class关键定义类以及继承的区别
1. 定义类差别

struct关键字也可以实现类，用class和struct关键字定义类的**唯一差别在于默认访问级别**：默认情况下，struct成员的访问级别为public，而class成员的为private。语法使用也相同，直接将class改为struct即可。

2. 继承差别
使用class保留字的派生类默认具有private继承，而用struct保留字定义的类某人具有public继承。其它则没有任何区别。

主要点就两个：默认的访问级别和默认的继承级别 class都是private

## 8.14 深拷贝与浅拷贝
<center>

![](https://pic2.zhimg.com/80/v2-56b79a660af6fc485c49e4ff8d5de58d_720w.jpg)

</center>

**浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存**。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。
## 8.15 虚函数，虚函数表里面内存如何分配？
[虚函数]((https://blog.csdn.net/lihao21/article/details/50688337))
编译时若基类中有虚函数，编译器为该的类创建一个一维数组的虚表，存放是每个虚函数的地址。基类和派生类都包含虚函数时，这两个类都建立一个虚表。构造函数中进行虚表的创建和虚表指针的初始化。在构造子类对象时，要先调用父类的构造函数，初始化父类对象的虚表指针，该虚表指针指向父类的虚表。执行子类的构造函数时，子类对象的虚表指针被初始化，指向自身的虚表。每一个类都有虚表。虚表可以继承，如果子类没有重写虚函数，那么子类虚表中仍然会有该函数的地址，只不过这个地址指向的是基类的虚函数实现。

## 8.16 为什么要用static_cast转换而不用c语言中的转换？
Static_cast转换，它会检查类型看是否能转换，有**类型安全检查**。

## 8.17 深入谈谈堆和栈
1. 分配和管理方式不同 ：
堆是动态分配的，其空间的分配和释放都由程序员控制。
栈由编译器自动管理。栈有两种分配方式：静态分配和动态分配。静态分配由编译器完成，比如局部变量的分配。动态分配由alloca()函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无须手工控制。
2. 产生碎片不同
对堆来说，频繁的new/delete或者malloc/free势必会造成内存空间的不连续，造成大量的碎片，使程序效率降低。
对栈而言，则不存在碎片问题，因为栈是先进后出的队列，永远不可能有一个内存块从栈中间弹出。
3. 生长方向不同
堆是向着内存地址增加的方向增长的，从内存的低地址向高地址方向增长。
栈是向着内存地址减小的方向增长，由内存的高地址向低地址方向增长。

## 8.17 内存的静态分配和动态分配的区别？
1. 时间不同。
   静态分配发生在程序编译和连接时。动态分配则发生在程序调入和执行时。
2. 空间不同。
   堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。alloca，可以从栈里动态分配内存，不用担心内存泄露问题，当函数返回时，通过alloca申请的内存就会被自动释放掉。
## 8.18 多线程锁的种类有哪些？
1. 互斥锁（mutex）
2. 读写锁
3. 递归锁 
4. 自旋锁 

## 8.19 动态链接和静态链接的区别？
动态链接是只建立一个引用的接口，而真正的代码和数据存放在另外的可执行模块中，在可执行文件运行时再装入；而静态链接是把所有的代码和数据都复制到本模块中，运行时就不再需要库了。

## 8.20 析构函数定位虚函数的作用

当一个继承类经由一个基类的指针删除时，而该基类包含的是一个非虚析构函数，其结果是未定义的（实际执行时通常发生的是继承类的独有成分没有被销毁)。这个后果很严重，会造成**内存泄漏**。

通过基类指针删继承类时，需要特别注意！！
```cpp
/*
* 当一个继承类经由一个基类的指针删除时，而该基类包含的是一个非虚析构函数，
* 其结果是未定义的（实际执行时通常发生的是继承类的独有成分没有被销毁)。
* 这个后果很严重，会造成内存泄漏。
*
* 通过基类指针删继承类时，需要特别注意！！
*/

#include <iostream>
using namespace std;

class Base{
public:
    Base (){
        cout<<"Base 构造函数执行了！"<<endl;
    }
    virtual ~Base(){
        cout<<"Base 析构函数执行了！"<<endl;
    }
    virtual void func(){
        cout<<"Base::func 虚函数执行了！"<<endl;
    }
};
class Derived :public Base
{
public:
    Derived(){
        cout<<"Derived 构造函数执行了！"<<endl;
    }
    ~Derived(){
        cout<<"Derived 析构函数执行了！"<<endl;
    }
    virtual void func(){
        cout<<"Derived::func 虚函数执行了！"<<endl;
    }
};

int main()
{
    Base *p;
    p=new Derived;
    p->func();

    delete  p;      //!此时只会执行Base的析构函数，不会执行Dervied的析构函数，从而导致内存泄露；
                        //!解决方法==>>将基类的析构函数定义为虚函数；
    return 0;
}

//------------------------------------输出信息-----------------------------------//
Base 构造函数执行了！               //先构造基类
Derived 构造函数执行了！            //再构造继承类
Derived::func 虚函数执行了！
Derived 析构函数执行了！            //先析构继承类
Base 析构函数执行了！               //在析构子类

//------------------------------------主函数修改-----------------------------------//
int main()
{
    Derived d;
    d.func();
}
//------------------------------------输出信息-----------------------------------//
Base 构造函数执行了！
Derived 构造函数执行了！
Derived::func 虚函数执行了！
Derived 析构函数执行了！
Base 析构函数执行了！

//==>> 局部对象在声明结束时自动析构；
//==>> 在构造对象的时候，先构造基类，再构造继承类；在析构的时候，先析构继承类，再析构基类；即先构造的后析构；

//------------------------------------主函数修改-----------------------------------//
int main()
{
    Derived *d2=new Derived;
    d2->func();
}
//------------------------------------输出信息-----------------------------------//
Base 构造函数执行了！
Derived 构造函数执行了！
Derived::func 虚函数执行了！

//==>> 不会执行析构函数！！
//==>> 所以，通过new在堆上划分的内存必须需要通过手动释放，不然会导致内存泄露！！==>delete d2;
```

## 8.21 互斥锁，条件锁，自旋锁，读写锁
### 8.21.1 互斥锁
互斥锁用于控制多个线程对他们之间共享资源互斥访问的一个信号量。也就是说是为了避免多个线程在某一时刻同时操作一个共享资源。例如线程池中的有多个空闲线程和一个任务队列。任何是一个线程都要使用互斥锁互斥访问任务队列，以避免多个线程同时访问任务队列以发生错乱。

在某一时刻，只有一个线程可以获取互斥锁，在释放互斥锁之前其他线程都不能获取该互斥锁。如果其他线程想要获取这个互斥锁，那么这个线程只能以**阻塞方式**进行等待。

### 8.21.2 条件锁

条件锁就是所谓的条件变量，某一个线程因为某个条件为满足时可以使用条件变量使改程序处于阻塞状态。一旦条件满足以“信号量”的方式唤醒一个因为该条件而被阻塞的线程。


### 8.21.3 自旋锁
假设我们有一个两个处理器core1和core2计算机，现在在这台计算机上运行的程序中有两个线程：T1和T2分别在处理器core1和core2上运行，两个线程之间共享着一个资源。

首先我们说明互斥锁的工作原理，互斥锁是是一种sleep-waiting的锁。假设线程T1获取互斥锁并且正在core1上运行时，此时线程T2也想要获取互斥锁（pthread_mutex_lock），但是由于T1正在使用互斥锁使得T2被阻塞。当T2处于阻塞状态时，T2被放入到等待队列中去，处理器core2会去处理其他任务而不必一直等待（忙等）。也就是说处理器不会因为线程阻塞而空闲着，它去处理其他事务去了。

而自旋锁就不同了，自旋锁是一种busy-waiting的锁。也就是说，如果T1正在使用自旋锁，而T2也去申请这个自旋锁，此时T2肯定得不到这个自旋锁。与互斥锁相反的是，此时运行T2的处理器core2会一直不断地循环检查锁是否可用（自旋锁请求），直到获取到这个自旋锁为止。

从“自旋锁”的名字也可以看出来，如果一个线程想要获取一个被使用的自旋锁，那么它会一致占用CPU请求这个自旋锁使得CPU不能去做其他的事情，直到获取这个锁为止，这就是“自旋”的含义。

当发生阻塞时，互斥锁可以让CPU去处理其他的任务；而自旋锁让CPU一直不断循环请求获取这个锁。通过两个含义的对比可以我们知道“自旋锁”是比较耗费CPU的


### 8.21.4 读写锁
计算机中某些数据被多个进程共享，对数据库的操作有两种：一种是读操作，就是从数据库中读取数据不会修改数据库中内容；另一种就是写操作，写操作会修改数据库中存放的数据。因此可以得到我们允许在数据库上同时执行多个“读”操作，但是某一时刻只能在数据库上有一个“写”操作来更新数据。这就是一个简单的读者-写者模型。


## 8.22 构造函数执行次数?
如果MyClass是一个类,执行"MyClass a[5],*b[6];,构造函数执行几次?"-->**执行5次**.

执行构造函数,就是开始构造对象,为对象划分内存;同理如果给指针new 一个内存空间时,就会调用构造函数;

```cpp
    MyClass a[5],*b[6];
            //a[5]:生成一个数组,会分配5个对象;
            // *b[6]:生成一个指针数组,每一个元素可以指向一个数据类型为MyClass对象;但是,此时还没分配内存;


A a[5];
A *b[6];
for(int i=0;i<6;i++)
{
    b[i]=new A;//为b的每一个对象分配内存空间;
}

//此时,构造函数会调用11次;
```

## 8.24 char c=97;
已知char C；则下列语句中正确的是( c )。
(A)c='97'； //c是字符,所以只能存储一个
(B)c="7"；  // "7",字符串
(C)c=97；   //!<font color=blue>将一个整数赋值给一个字符串,实际上是以**该整型为ACII的字符**赋值为c</font>
(D)c="a"；  //"字符串";

## 9. 补充
### 9.1 static 关键字的作用

1. 全局静态变量

在全局变量前加上关键字 static,全局变量就定义成一个全局静态变量.静态存储区,在整个程序运行期间一直存在。
初始化:未经初始化的全局静态变量会被自动初始化为 0(自动对象的值是任意的,除非他被显式初始化);

作用域:**全局静态变量在声明他的文件之外是不可见的,准确地说是从定义之处开始,到文件结尾。**

2. 局部静态变量

在局部变量之前加上关键字 static,局部变量就成为一个局部静态变量。内存中的位置:静态存储区
初始化:未经初始化的全局静态变量会被自动初始化为 0(自动对象的值是任意的,除非他被显式初始化);

作用域:**作用域仍为局部作用域,当定义它的函数或者语句块结束的时候,作用域结束。但是当局部静态变量离开作用域后,并没有销毁,而是仍然驻留在内存当中,只不过我们不能再对它进行访问,直到该函数再次被调用,并且值不变;**

3. 静态函数

在函数返回类型前加 `static`,函数就定义为静态函数。函数的定义和声明在默认情况下都是 `extern` 的,但静态函数只是在声明他的文件当中可见,不能被其他文件所用。函数的实现使用 `static` 修饰,那么这个函数只可在本 `cpp` 内使用,不会同其他` cpp `中的同名函数引起冲突;

**warning**:不要再头文件中声明 static 的全局函数,不要在 cpp 内声明非 static 的全局函数,如果你要在多个 cpp 中复用该函数,就把它的声明提到头文件里去,否则 cpp 内部声明需加上 static 修饰;

4. 类的静态成员

在类中,静态成员可以实现多个对象之间的数据共享,并且使用静态数据成员还不会破坏隐藏的原则,即保证了安全性。因此,静态成员是类的所有对象中`共享的成员`,而不是某个对象的成员。对多个对象来说,静态数据成员只存储一处,供所有对象共用.

5. 类的静态函数
静态成员函数和静态数据成员一样,它们都属于类的静态成员,它们都不是对象成员。因此,对静态成员的引用不需要用对象名。

**在静态成员函数的实现中不能直接引用类中说明的非静态成员,可以引用类中说明的静态成员(这点非常重要)。如果静态成员函数中要引用非静态成员时,可通过对象来引用。**

### 9.2 C 语言参数压栈顺序?
从右到左

### 9.3 map 和 set 有什么区别,分别又是怎么实现的?
map 和 set 都是 C++的关联容器,其底层实现都是红黑树(RB-Tree)。
map 和 set 区别在于:

map 中的元素是 `key-value`(关键字—值)对:关键字起到索引的作用,值则表示与索引相关联的数据;
Set 与之相对就是关键字的简单集合,set 中每个元素只包含一个关键字。

set 的迭代器是 `const` 的,不允许修改元素的值;map 允许修改 `value`,但不允许修改key。其原因是因为 map 和 set 是根据关键字排序来保证其有序性的,如果允许修改 key 的话,那么首先需要删除该键,然后调节平衡,再插入修改后的键值,调节平衡,如此一来,严重破坏了 map 和 set 的结构,导致 iterator 失效,不知道应该指向改变前的位置,还是指向改变后的位置。所以 STL 中将 set 的迭代器设置成 const,不允许修改迭代器的值;而 map 的迭代器则不允许修改 key 值,允许修改 value 值。

map 支持下标操作,set 不支持下标操作。map 可以用 key 做下标,map 的下标运算符[ ]将关键码作为下标去执行查找,如果关键码不存在,则插入一个具有该关键码和 mapped_type类型默认值的元素至 map 中,因此下标运算符[ ]在 map 应用中需要慎用,const_map 不能用,只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用,mapped_type 类型没有默认值也不应该使用。如果 `find `能解决需要,尽可能用 `find`。

### 9.4 STL 迭代器删除元素
1.对于序列容器 `vector,deque` 来说,使用`erase`(itertor)后,**后边的每个元素的迭代器都会失效**,但是后边每个元素都会往前移动一个位置,但是 `erase` 会返回下一个有效的迭代器;

2.对于关联容器 `map set` 来说,使用了erase(iterator)后,**当前元素的迭代器失效**,但是其结构是红黑树,删除当前元素的,不会影响到下一个元素的迭代器,所以在调用 erase 之前,记录下一个元素的迭代器即可。

3.对于 list来说,它使用了不连续分配的内存,并且它的 erase 方法也会返回下一个有效的 iterator,因此上面两种正确的方法都可以使用。

### 9.5 vector 和 list 的区别?

1. Vector
连续存储的容器,动态数组,在堆上分配空间;
底层实现:数组
vector 增加(插入)新元素时,如果未超过当时的容量,则还有剩余空间,那么直接添加到最后(插入指定位置),然后调整迭代器。

如果没有剩余空间了,则会重新配置原有元素个数的两倍空间,然后将原空间元素通过复制的方式初始化新空间,再向新空间增加元素,最后析构并释放原空间,之前的`迭代器会失效`。

2. List
动态链表,在堆上分配空间,每插入一个元数都会分配空间,每删除一个元素都会释放空间。
底层:双向链表

**vector 和 list 的区别**

1)vector 底层实现是数组;list 是双向链表。
2)**vector 支持随机访问,list 不支持**。
3)vector 是顺序内存,list 不是。
4)vector 在**中间节点进行插入删除会导致内存拷贝**,list 不会。
5)vector 一次性分配好内存,不够时才进行 2 倍扩容;list 每次插入新节点都会进行内
存申请。
6)vector 随机访问性能好,插入删除性能差;list 随机访问性能差,插入删除性能好。

### 9.6 STL 中迭代器的作用,有指针为何还要迭代器?

1. 迭代器
Iterator(迭代器)模式又称 Cursor(游标)模式,用于提供**一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示**。

2. 迭代器和指针的区别
迭代器不是指针,是类模板,表现的像指针。他只是模拟了指针的一些功能,通过重载了指针的一些操作符,->、*、++、--等。

迭代器封装了指针,是一个“可遍历 STL( Standard TemplateLibrary)容器内全部或部分元素”的对象,**本质是封装了原生指针**,是指针概念的一种提升(lift),提供了比指针更高级的行为,相当于一种智能指针,他可以根据不同类型的数据结构来实现不同的++,--等操作。

3. 迭代器产生原因
Iterator 类的访问方式就是把**不同集合类的访问逻辑抽象出来**,使得不用暴露集合内部的结构而达到循环遍历集合的效果。

### 9.7 STL 里 resize 和 reserve 的区别?

1. resize():
`resize()`:改变当前容器内含有元素的数量(size()),

```cpp
vector<int>v;
v.resize(len);
```

v的 size 变为 len,如果原来 v 的 size 小于 len,那么容器新增(len-size)个元素,元素的值为默认为 0.当 v.push_back(3);之后,则是 3 是放在了 v 的末尾,即下标为 len,此时容器是 size为 len+1;

2. reserve():
`reserve()`:改变当前容器的最大容量(capacity),它不会生成元素,只是确定这个容器允许放入多少对象,如果 reserve(len)的值大于当前的 capacity(),那么会重新分配一块能存 len 个对象的空间,然后把之前 v.size()个对象通过 copy construtor 复制过来,销毁之前的内存;

```cpp
#include <iostream>
#include <list>
#include <vector>
#include <random>
using namespace std;
int main()
{
   vector<int> vec;
   vec.resize(10);
   cout<<"after resize(10):"<<vec.size()<<endl;         // 10 个元素,均设置为默认值0;
   vec.push_back(100);
   cout<<"after push_back(100):"<<vec.size()<<endl;     // 11 个元素,最后一个元素是 100;
   int i=1;
   for(auto &O:vec)
   {
       cout<<"第"<<i<<"个元素:"<<O<<endl;
       i++;
   }

   vec.reserve(100);
   cout<<"after reserve:"<<vec.size()<<endl;
   return 0;
}

/*
after resize(10):10
after push_back(100):11
第1个元素:0
第2个元素:0
第3个元素:0
第4个元素:0
第5个元素:0
第6个元素:0
第7个元素:0
第8个元素:0
第9个元素:0
第10个元素:0
第11个元素:100
after reserve:11
*/
```
## 9.8 A* a = new A; a->i = 10;在内核中的内存分配上发生了什么?
```cpp
A* a = new A; 
a->i = 10;
```
1)A *a:a 是一个**局部变量**,类型为指针,故而操作系统在程序栈区开辟 4/8 字节的空间(0x000m),分配给指针 a。
2)new A:通过 new 动态的在堆区申请类 A 大小的空间(0x000n)。
3)a = new A:将指针 a 的内存区域填入栈中类 A 申请到的地址的地址。即*(0x000m)=0x000n。
4)a->i:先找到指针 a 的地址 0x000m,通过 a 的值 0x000n 和 i 在类 a 中偏移 offset,得到 a->i 的地址 0x000n + offset,进行*(0x000n + offset) = 10 的赋值操作,即内存 0x000n +offset 的值是 10。

## 9.9 请问 GDB 调试用过吗,什么是条件断点
条件断点是当满足条件就中断程序运行,命令:break `line-or-function` if expr。
例如:(gdb)break 666 if testsize==100

## 10.1 请你来介绍一下 5 种 I/O 模型
1. 阻塞 I/O:调用者调用了某个函数,等待这个函数返回,期间什么也不做,**不停的去检查这个函数有没有返回**,必须等这个函数返回才能进行下一步动作;
2. 非阻塞 I/O:非阻塞等待,每隔一段时间就去检测 I/O 事件是否就绪。没有就绪就可以做其他事。
3. 信号驱动 I/O:linux 用套接口进行信号驱动 I/O,安装一个信号处理函数,进程继续运行并不阻塞,当 I/O 时间就绪,进程收到 SIGIO 信号。然后处理 I/O 事件。
4. I/O 复用/多路转接 I/O:linux 用 select/poll 函数实现 I/O 复用模型,这两个函数也会使进程阻塞,但是和阻塞 I/O 所不同的是这两个函数可以同时阻塞多个 I/O 操作。而且可以同时对多个读操作、写操作的 I/O 函数进行检测。知道有数据可读或可写时,才真正调用 I/O 操作函数
5. 异步 I/O:linux 中,可以调用 aio_read 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式,然后立即返回,当内核将数据拷贝到缓冲区后,再通知应用程序。

## 10.2 简单的程序题!!


```cpp
int a[10]={0};下列输出错误的是:

A. cout<<(*a)<<endl;
B. cout<<(a+1)<<endl;
C. cout<<(a++)<<endl;
D. cout<<(a[0])<<endl;
```
`*a` 等价于 `a[0]`,`cout<<(a+1)<<endl;`输出的是&a[1]的地址;
**a++是错误的!!**  a存储的是数组的a的首地址,是不可以改变的;如果是一个指针`*p=a;p++`是可以的;

--- 
```cpp
#define P 3

void func(int x)
{
    cout<<P*x+x<<endl;
}

int main()
{
    func(3+3); //==>输出是?
}
```
答案:24 进行机械替换只是针对`宏定义: #define `的值;`func(3+3)`;中在编译的时候,就会计算出`3+3=6`;

---
```cpp
浮点数++或--;        //浮点数进行++或--运算;

float f=2.58;
double d=3.333;
float ff=0.52;

cout<<f++<<endl;    //!注意这块输出的是 2.58 !!!,f先参与计算,再进行自增
cout<<f<<endl;      // 3.25 !!!

cout<<++d<<endl;    // 4.333 

cout<<--f<<endl;    //0.52-1=   -0.48;
```
---

下列描述正确的是:-->B

```cpp
int *p1=new int[10];
int *p2=new int[10]();//p1申请空间的值是随机值,p2申请空间的值已经初始化;
```
A.p1和p2申请空间的值都是随机值;
B.p1申请空间的值是随机值,p2申请空间的值已经初始化;
对于内置类型而言，new仅仅是分配内存，除非后面显示加(),相当于调用它的构造函数，对于自定义类型而言，只要一调用new，那么编译器不仅仅给它分配内存，还调用它的默认构造函数初始化，即使后面没有加() 

---

```cpp
//sizeof(a)会计算占用内存大小;
void Func(char str_arg[100]) //浅拷贝 此处的100 不要被误导
{
       printf("%d\n",sizeof(str_arg)); //占用 4/8个字节:-->str_arg 一个指针占用内存
}
int main(void)
{
     char str[]="Hello";

    printf("%d\n",sizeof(str));         // 6 数组大小 -->包含'\0'

    printf("%d\n",strlen(str));         // 5 字符串长度  --> 不包含'\0'
    
    char*p=str;
    printf("%d\n",sizeof(p));           // 占用 4/8个字节 指针p 指向 一个字符数组,只计算指针大小

    int a[100];
    printf("%d\n",sizeof(a));           // 400 字节; 4*100;
    Func(str);
}
```
sizeof()主要是区别:如果传递是数组名,就会计算出数组占用的内存大小;
**如果将数组名传递给一个指针,则只会计算这个指针占用内存大小;**

---

注意局部变量:
```cpp
#include<stdio.h>
char *myString()
{
    char buffer[6] = {0};
    char *s = "Hello World!";
    for (int i = 0; i < sizeof(buffer) - 1; i++)
    {
        buffer[i] = *(s + i);
    }
    
    return buffer;
}
int main(int argc, char **argv)
{
    printf("%s\n", myString());
    return 0;
}
```

函数char `*myString()`中没有使用**new或者malloc分配内存，所有buffer数组的内存区域在栈区随着char `*myString`()的结束，栈区内存释放，字符数组也就不存在了**，所以会产生野指针，输出结果未知;

---
```cpp
#define INT_PTR int*
typedef int*int_ptr;
INT_PTR a,b;
int_ptr c,d;
```
文件中定义的四个变量，哪个变量不是指针类型？
**NT_PTR 会被int `*`直接替换**，所以最终的结果是int * a,b由此可见a是指针，而b不是。 

---
下列不属于hash碰撞解决方法的是（）。
正确答案: B 

A 线性探测

B 单旋转法

C 二次探测

D 拉链法

E 双重散列

F 多重散列

---

