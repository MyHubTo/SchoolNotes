## 1. 进程与线程的区别

### 1.1 基本概念
进程是对运行时程序的封装,是系统进行资源调度和分配的的基本单位,实现了操作系统的并发;
线程是进程的子任务,是 CPU 调度和分配的基本单位,用于保证程序的实时性,实现进程内部的并发;线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器:独自的寄存器组,指令计数器和处理器状态。每个线程完成不同的任务,但是共享同一地址空间(也就是同样的动态内存,映射文件,目标代码等等),打开的文件队列和其他内核资源。

### 1.2 区别:
1. 一个线程只能属于一个进程,而一个进程可以有多个线程,但至少有一个线程。线程依赖于进程而存在。
   
2. 进程在执行过程中拥有独立的内存单元,而多个线程共享进程的内存。(资源分配给进程,同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段(代码和常量),数据段(全局变量和静态变量),扩展段(堆存储)。 **但是每个线程拥有自己的栈段,栈段又叫运行时段,用来存放所有局部变量和临时变量。**) 
   
3. 进程是资源分配的最小单位,线程是 CPU 调度的最小单位;
   
4. 系统开销: 由于在创建或撤消进程时,系统都要为之分配或回收资源,如内存空间、I/O 设备等。因此,操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地,在进行进程切换时,涉及到整个当前进程 CPU 环境的保存以及新被调度运行的进程的 CPU 环境的设置。而线程切换只须保存和设置少量寄存器的内容,并不涉及存储器管理方面的操作。可见,进程切换的开销也远大于线程切换的开销。
   
5. 通信:由于同一进程中的多个线程具有相同的地址空间,致使它们之间的同步和通信的实现,也变得比较容易。进程间通信 IPC,线程间可以直接读写进程数据段(如全局变量)来进行通信——需要进程同步和互斥手段的辅助,以保证数据的一致性。在有的系统中,线程的切换、同步和通信都无须操作系统内核的干预.


6. 进程编程调试简单可靠性高,但是创建销毁开销大;线程正相反,开销小,切换速度快,但是编程调试相对复杂。

7. 进程间不会相互影响 ;线程一个线程挂掉将导致整个进程挂掉;

### 1.3 进程间通信的方式:
进程间通信主要包括管道、系统 `IPC`(包括消息队列、信号量、信号、共享内存等)、以及套接字 `socket`(不同主机)。

### 1.4 线程同步方式:
**互斥量** Synchronized/Lock:采用互斥对象机制,只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个,所以可以保证公共资源不会被多个线程同时访问;
**临界区(windows)**:通过多线程的串行化来访问公共资源或一段代码,速度快,适合控制数据访问;
**事件(信号)**,Wait/Notify:通过通知操作的方式来保持多线程同步,还可以方便的实现多线程优先级的比较操作;

**信号量 Semphare**:为控制具有有限数量的用户资源而设计的,它允许多个线程在同一时刻去访问同一个资源,但一般需要限制同一时刻访问此资源的最大线程数目。

## 2.Linux 虚拟地址空间
### 2.1 基本概念

为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏,采用了虚拟内存。

虚拟内存技术使得不同进程在运行过程中,它所看到的是自己独自占有了当前系统的内存。所有进程共享同一物理内存,每个进程**只把自己目前需要的虚拟内存空间映射并存储到物理内存上**。 事实上,在每个进程创建加载时,内核只是为进程“创建”了虚拟内存的布局,具体就是初始化进程控制表中内存相关的链表,实际上并不立即就把虚拟内存对应位置的程序数据和代码(比如.text .data 段)拷贝到物理内存中,**只是建立好虚拟内存和磁盘文件之间的映射**就好(叫做存储器映射),等到**运行到对应的程序时,才会通过缺页异常,来拷贝数据**。还有进程运行过程中,要动态分配内存,比如 malloc 时,也只是分配了虚拟内存,即为这块虚拟内存对应的页表项做相应设置,当进程真正访问到此数据时,才引发缺页异常。请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的,通过请求实现内存与外存的信息置换。

### 2.1 虚拟内存的好处:
1. 扩大地址空间;
2. 内存保护:每个进程运行在各自的虚拟内存地址空间,互相不能干扰对方。虚存还对特定的内存地址提供写保护,可以防止代码或数据被恶意篡改。
3. 公平内存分配。采用了虚存之后,每个进程都相当于有同样大小的虚存空间。
4. 当进程通信时,可采用虚存共享的方式实现。
5. 当不同的进程使用同样的代码时,比如库文件中的代码,物理内存中可以只存储一份这样的代码,不同的进程只需要把自己的虚拟内存映射过去就可以了,节省内存.
6. 虚拟内存很适合在多道程序设计系统中使用,许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时,可以把 CPU 交给另一个进程使用。在内存中可以保留多个进程,系统并发度提高.
7. 在程序需要分配连续的内存空间的时候,只需要在虚拟内存空间分配连续空间,而不需要实际物理内存的连续空间,可以利用碎片.

### 2.3 虚拟内存的代价:
1. 虚存的管理需要建立很多数据结构,这些数据结构要占用额外的内存;
2. 虚拟地址到物理地址的转换,增加了指令的执行时间。
3. 页面的换入换出需要磁盘 I/O,这是很耗时的
4. 如果一页中只有一部分数据,会浪费内存。

##　３．操作系统中的缺页中断

malloc()和 mmap()等内存分配函数,在分配时**只是建立了进程虚拟地址空间,并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时,处理器自动触发一个缺页异常。**

缺页中断:在请求分页系统中,可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是,会产生一次缺页中断,此时操作系统会根据页表中的外存地址在外存中找到所缺的一页,将其调入内存。

缺页本身是一种中断,与一般的中断一样,需要经过 4 个处理步骤:
1. 保护 CPU 现场
2. 分析中断原因
3. 转入缺页中断处理程序进行处理
4. 恢复 CPU 现场,继续执行
但是缺页中断是由于所要访问的页面不存在于内存时,由硬件所产生的一种特殊的中断,因此,与一般的中断存在区别:
1. 在指令执行期间产生和处理缺页中断信号
2. 一条指令在执行期间,可能产生多次缺页中断
3. 缺页中断返回是,执行产生中断的一条指令,而一般的中断返回是,执行下一条指令

## 4. fork 和 vfork 的区别
### 4.1 fork 的基础知识:
fork:创建一个和当前进程映像一样的进程可以通过 fork()系统调用:
成功调用 fork()会创建一个新的进程,它几乎与调用 fork()的进程一模一样,这两个进程都会继续运行。在子进程中,成功的 fork()调用会返回 0。在父进程中 fork()返回子进程的 pid。如果出现错误,fork( )返回一个负值。

最常见的 fork( )用法是创建一个新的进程,然后使用 exec( )载入二进制映像,替换当前进程的映像。这种情况下,派生(fork)了新的进程,而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。在早期的 Unix 系统中,创建进程比较原始。当调用 fork 时,内核会把所有的内部数据结构复制一份,复制进程的页表项,然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说,逐页的复制方式是十分耗时的。现代的 Unix 系统采取了更多的优化,例如 Linux,采用了写时复制的方法,而不是对父进程空间进程整体复制。

### 4.2 vfork 的基础知识:
在实现写时复制之前,Unix 的设计者们就一直很关注在 fork 后立刻执行 exec 所造成的地址空间的浪费。BSD 的开发者们在 3.0 的 BSD 系统中引入了 vfork( )系统调用。

除了子进程必须要立刻执行一次对 exec 的系统调用,或者调用_exit( )退出,对 vfork( )的成功调用所产生的结果和 fork( )是一样的。vfork( )会挂起父进程直到子进程终止或者运行了一个新的可执行文件的映像。通过这样的方式,vfork( )避免了地址空间的按页复制。在这个过程中,父进程和子进程共享相同的地址空间和页表项。实际上 vfork( )只完成了一件事:复制内部的内核数据结构。因此,子进程也就不能修改地址空间中的任何内存。

vfork( )是一个历史遗留产物,Linux 本不应该实现它。需要注意的是,即使增加了写时复制,vfork( )也要比 fork( )快,因为它没有进行页表项的复制。然而,写时复制的出现减少了对于替换 fork( )争论。实际上,直到 2.2.0 内核,vfork( )只是一个封装过的 fork( )。因为对 vfork( )的需求要小于 fork( ),所以 vfork( )的这种实现方式是可行的。

fork 和 vfork 的区别:
1. fork( )的子进程拷贝父进程的数据段和代码段;vfork( )的子进程与父进程共享数据段
2. fork( )的父子进程的执行次序不确定;vfork( )保证子进程先运行,在调用 exec 或 exit之前与父进程数据是共享的,在它调用 exec 或 exit 之后父进程才可能被调度运行。
3. vfork( )保证子进程先运行,在它调用 exec 或 exit 之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作,则会导致死锁。
4. 当需要改变共享数据段中变量的值,则拷贝父进程。