## 1.启动线程
```cpp
#include<iostream>
#include<thread>        //A
using namespace std;
void print()            //B
{
    cout<<"-----------test-------------"<<endl;
}
int main()
{
    cout<<"test start"<<endl;
    thread t(print);    //C 创建一个线程，其入口函数为print   
    t.join();           //D 等待线程结束，并加入主线程中
    return 0;
}

```
多线程与普通程序相比较：
1. 第一个区别是增加了`#include<thread>`,A，标准C++库中对多线程支持的声明在新的头文件中；**管理线程**的函数和类在`<thread>`中声明，而**保护共享数据**的函数和类在其他文件中声明；
2. print函数需要独立，B,这是因为每一个线程都必须具有一个初始函数，新线程的执行从这里开始。对于应用程序而言，初始线程是`main()`，但是对于其他线程，可以在`std::thread`对象的构造函数中指定；如：并命名为t的`std::thread()`的对象拥有新函数`print`作为其初始函数；与直接写入标准输出或是从main()调用print()不同，该程序启动了一个线程来实现，将线程数量一分为二——**初始线程始于main(),而新线程始于print();**
3. 新的线程启动之后C,初始线程继续执行。如果它不等待新线程结束，它就将自顾自地继续运行到`main()`结束，从而结束程序，此时若新线程在`main()`结束之前还没有没有结束，就会导致程序出错。所以，此处调用`jion()`的原因，这会导致调用`线程(main())`**等待**与`std::thread`对象相关联的线程，即本例中t;
